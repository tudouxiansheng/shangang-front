var StarRtc = window.NameSpace || {};
var sdpUtils = new SdpUtils;

function extractVersion(e, i, t) {
  var a = e.match(i);
  return a && a.length >= t && parseInt(a[t], 10)
}

function detectBrowser(e) {
  var i = e.navigator,
    t = {
      browser: null,
      version: null
    };
  if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
  if (i.mozGetUserMedia) t.browser = "firefox", t.version = extractVersion(i.userAgent, /Firefox\/(\d+)\./, 1);
  else if (i.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = extractVersion(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (i.mediaDevices && i.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = extractVersion(i.userAgent, /Edge\/(\d+).(\d+)$/, 2);
  else {
    if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
    t.browser = "safari", t.version = extractVersion(i.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
  }
  return t
}

function ICEInfo() {
  this.iceUfrag = "", this.icePwd = "", this.iceOptions = "", this.iceLite = !1
}

function FingerprintInfo() {
  this.algorithm = "", this.value = ""
}

function CodecInfo() {
  this.payload = 0, this.codecName = "", this.codecInterval = "", this.rtcpFB = [], this.fmtp = []
}

function SSRCInfo() {
  this.ssrc = 0, this.cname = "", this.mslabel = "", this.label = "", this.msid = ""
}

function MediaDesc() {
  this.type = "", this.protocol = "UDP/TLS/RTP/SAVPF", this.iceInfo = new ICEInfo, this.fingerprintInfo = new FingerprintInfo, this.setup = "", this.mid = "", this.msid = "", this.extmap = {}, this.commAbility = "sendrecv", this.rtcpMux = !0, this.rtcpResize = !1, this.codecInfoMap = {}, this.codecInfoArray = [], this.ssrcInfoMap = {}, this.ssrcInfoArray = [], this.ssrcGroup = [], this.candidate = []
}

function SdpDesc() {
  this.version = 0, this.username = "-", this.sessionID = 0, this.sessionVersion = 0, this.sessionName = "-", this.sessionStartTime = 0, this.sessionEndTime = 0, this.iceInfo = new ICEInfo, this.fingerprintInfo = new FingerprintInfo, this.group = [], this.wms = [], this.mediaDesc = []
}

function SdpUtils() {
  SdpUtils.prototype.clone = function e(i) {
    if (null == i || "object" != typeof i) return i;
    if (i instanceof Date) return (t = new Date).setTime(i.getTime()), t;
    if (i instanceof Array) {
      for (var t = [], a = i.length, r = 0; r < a; ++r) t[r] = e(i[r]);
      return t
    }
    if (i instanceof Object) {
      t = {};
      for (var n in i) i.hasOwnProperty(n) && (t[n] = e(i[n]));
      return t
    }
    throw new Error("Unable to copy obj! Its type isn't supported.")
  }, SdpUtils.prototype.parseSdp = function (e) {
    var i = new SdpDesc,
      t = e.split("\r\n"),
      a = !1,
      r = null;
    for (var n in t) {
      switch (t[n].charAt(0)) {
        case "v":
          i.version = parseInt(t[n].substring(2));
          break;
        case "o":
          var s = t[n].substring(2).split(" ");
          i.username = s[0], i.sessionID = s[1], i.sessionVersion = s[2];
          break;
        case "s":
          i.sessionName = t[n].substring(2);
          break;
        case "t":
          s = t[n].substring(2).split(" ");
          i.sessionStartTime = parseInt(s[0]), i.sessionEndTime = parseInt(s[1]);
          break;
        case "m":
          null != r && (i.mediaDesc.push(r), r = null);
          s = t[n].substring(2).split(" ");
          (r = new MediaDesc).type = s[0], r.protocol = s[2];
          for (n = 3; n < s.length; ++n) {
            (o = new CodecInfo).payload = parseInt(s[n]), r.codecInfoMap[o.payload] = o, r.codecInfoArray.push(o)
          }
          a = !0;
          break;
        case "a":
          if (a) {
            if (-1 != t[n].indexOf("a=ice-ufrag:")) r.iceInfo.iceUfrag = t[n].substring(12);
            else if (-1 != t[n].indexOf("a=ice-pwd:")) r.iceInfo.icePwd = t[n].substring(10);
            else if (-1 != t[n].indexOf("a=ice-options:")) r.iceInfo.iceOptions = t[n].substring(14);
            else if (-1 != t[n].indexOf("a=ice-lite")) r.iceInfo.iceLite = !0;
            else if (-1 != t[n].indexOf("a=fingerprint:")) {
              s = t[n].substring(14).split(" ");
              r.fingerprintInfo.algorithm = s[0], r.fingerprintInfo.value = s[1]
            } else if (-1 != t[n].indexOf("a=setup:")) r.setup = t[n].substring(8);
            else if (-1 != t[n].indexOf("a=mid:")) r.mid = t[n].substring(6);
            else if (-1 != t[n].indexOf("a=extmap:")) {
              s = t[n].substring(9).split(" ");
              r.extmap[s[0]] = s[1]
            } else if (-1 != t[n].indexOf("a=rtcp-mux")) r.rtcpMux = !0;
            else if (-1 != t[n].indexOf("a=rtcp-rsize")) r.rtcpResize = !0;
            else if (-1 != t[n].indexOf("a=sendrecv") || -1 != t[n].indexOf("a=sendonly") || -1 != t[n].indexOf("a=recvonly") || -1 != t[n].indexOf("a=inactive")) r.commAbility = t[n].substring(2);
            else if (-1 != t[n].indexOf("a=rtpmap:")) {
              s = t[n].substring(9).split(" ");
              var o = r.codecInfoMap[s[0]],
                c = s[1].indexOf("/");
              s[1].split("/");
              o.codecName = s[1].substring(0, c), o.codecInterval = s[1].substring(c + 1)
            } else if (-1 != t[n].indexOf("a=rtcp-fb:")) {
              c = t[n].indexOf(" ");
              var d = t[n].substring(10, c);
              s = t[n].substring(c + 1);
              (o = r.codecInfoMap[d]).rtcpFB.push(s)
            } else if (-1 != t[n].indexOf("a=fmtp:")) {
              s = t[n].substring(7).split(" ");
              (o = r.codecInfoMap[s[0]]).fmtp.push(s[1])
            } else if (-1 != t[n].indexOf("a=msid:")) {
              var l = t[n].substring(7);
              r.msid = l
            } else if (-1 != t[n].indexOf("a=ssrc:")) {
              c = t[n].indexOf(" ");
              var f = t[n].substring(7, c),
                p = (s = t[n].substring(c + 1).split(":"), r.ssrcInfoMap[f]);
              p || ((p = new SSRCInfo).ssrc = f, r.ssrcInfoArray.push(p)), "cname" == s[0] ? p.cname = s[1] : "msid" == s[0] ? p.msid = s[1] : "mslabel" == s[0] ? p.mslabel = s[1] : "label" == s[0] && (p.label = s[1]), r.ssrcInfoMap[f] = p
            } else if (-1 != t[n].indexOf("a=ssrc-group:")) {
              s = t[n].substring(13).split(" ");
              for (var n in s) r.ssrcGroup.push(s[n])
            } else if (-1 != t[n].indexOf("a=candidate:")) {
              s = t[n].substring(12);
              r.candidate.push(s)
            }
          } else if (-1 != t[n].indexOf("group:BUNDLE")) {
            var s = t[n].split(" ");
            for (n = 1; n < s.length; ++n) i.group.push(s[n])
          } else if (-1 != t[n].indexOf("msid-semantic:")) {
            var s = t[n].split(" ");
            i.wms.push(s[s.length - 1])
          } else if (-1 != t[n].indexOf("a=ice-ufrag:")) i.iceInfo.iceUfrag = t[n].substring(12);
          else if (-1 != t[n].indexOf("a=ice-pwd:")) i.iceInfo.icePwd = t[n].substring(10);
          else if (-1 != t[n].indexOf("a=ice-options:")) i.iceInfo.iceOptions = t[n].substring(14);
          else if (-1 != t[n].indexOf("a=ice-lite")) i.iceInfo.iceLite = !0;
          else if (-1 != t[n].indexOf("a=fingerprint:")) {
            var s = t[n].substring(14).split(" ");
            i.fingerprintInfo.algorithm = s[0], i.fingerprintInfo.value = s[1]
          }
      }
    }
    return null != r && (i.mediaDesc.push(r), r = null), i
  }, SdpUtils.prototype.genIceInfoSdp = function (e) {
    var i = "";
    return "" != e.iceUfrag && (i += "a=ice-ufrag:" + e.iceUfrag + "\r\n"), "" != e.icePwd && (i += "a=ice-pwd:" + e.icePwd + "\r\n"), e.iceLite ? i += "a=ice-lite\r\n" : "" != e.iceOptions && (i += "a=ice-options:" + e.iceOptions + "\r\n"), i
  }, SdpUtils.prototype.genFingerprintSdp = function (e) {
    var i = "";
    return "" != e.algorithm && (i += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"), i
  }, SdpUtils.prototype.genCodecSdp = function (e) {
    var i = "";
    for (var t in i += "a=rtpmap:" + e.payload + " " + e.codecName + "/" + e.codecInterval + "\r\n", e.rtcpFB) i += "a=rtcp-fb:" + e.payload + " " + e.rtcpFB[t] + "\r\n";
    for (var t in e.fmtp) i += "a=fmtp:" + e.payload + " " + e.fmtp[t] + "\r\n";
    return i
  }, SdpUtils.prototype.genSSRCSdp = function (e) {
    var i = "";
    return e.cname && (i += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), e.msid && (i += "a=ssrc:" + e.ssrc + " msid:" + e.msid + "\r\n"), e.mslabel && (i += "a=ssrc:" + e.ssrc + " mslabel:" + e.mslabel + "\r\n"), e.label && (i += "a=ssrc:" + e.ssrc + " label:" + e.label + "\r\n"), i
  }, SdpUtils.prototype.genMediaSdp = function (e) {
    var i = "";
    i += "m=" + e.type + " 9 " + e.protocol;
    var t = "";
    for (var a in e.codecInfoArray) {
      var r = e.codecInfoArray[a];
      i += " " + r.payload, t += this.genCodecSdp(r)
    }
    for (var a in i += "\r\n", i += "c=IN IP4 0.0.0.0\r\n", e.candidate) i += "a=candidate:" + e.candidate[a] + "\r\n";
    for (var n in 0 < e.candidate.length && (i += "a=end-of-candidates\r\n"), i += "a=" + e.commAbility + "\r\n", i += "a=setup:" + e.setup + "\r\n", i += "a=mid:" + e.mid + "\r\n", e.msid && (i += "a=msid:" + e.msid + "\r\n"), i += this.genIceInfoSdp(e.iceInfo), i += this.genFingerprintSdp(e.fingerprintInfo), 1 == e.rtcpMux && (i += "a=rtcp-mux\r\n"), 1 == e.rtcpResize && (i += "a=rtcp-rsize\r\n"), e.extmap) i += "a=extmap:" + n + " " + e.extmap[n] + "\r\n";
    for (var a in i += t, e.ssrcGroup.length && (i += "a=ssrc-group:FID " + e.ssrcGroup.join(" ") + "\r\n"), e.ssrcInfoArray) i += this.genSSRCSdp(e.ssrcInfoArray[a]);
    return i
  }, SdpUtils.prototype.genSdp = function (e) {
    var i = "";
    i += "v=" + e.version + "\r\n", i += "o=" + e.username + " " + e.sessionID + " " + e.sessionVersion + " IN IP4 127.0.0.1\r\n", i += "s=" + e.sessionName + "\r\n", i += "t=" + e.sessionStartTime + " " + e.sessionEndTime + "\r\n";
    var t = "",
      a = "";
    for (var r in e.mediaDesc) a += " " + e.mediaDesc[r].mid, t += this.genMediaSdp(e.mediaDesc[r]);
    return "" != a && (i += "a=group:BUNDLE" + a + "\r\n"), 0 != e.wms.length && (i += "a=msid-semantic:WMS *\r\n"), i += this.genIceInfoSdp(e.iceInfo), i += this.genFingerprintSdp(e.fingerprintInfo), i += t
  }
}
var StarWebRTC = function (e) {
  var n = RTCPeerConnection,
    r = (navigator.mediaDevices.getUserMedia, RTCIceCandidate, RTCSessionDescription),
    s = detectBrowser(window),
    m = e || {
      iceServers: [],
      iceTransportPolicy: "all",
      bundlePolicy: "balanced",
      rtcpMuxPolicy: "require",
      iceCandidatePoolSize: 0
    };
  null == m.sdpSemantics && (m.sdpSemantics = "unified-plan", "chrome" == s.browser ? s.version < 72 && (m.sdpSemantics = "plan-b") : "safari" == s.browser && (s.supportsUnifiedPlan || (m.sdpSemantics = "plan-b"))), null == m.iceControlRole && (m.iceControlRole = "controlled", "firefox" == s.browser && (m.iceControlRole = "controlling"));

  function i() {
    this.events = {}
  }

  function t() {
    this.localMediaStream = null, this.room = "", this.fileData = {}, this.socket = null, this.me = null, this.peerConnections = {}, this.connections = [], this.numStreams = 0, this.initializedStreams = 0, this.dataChannels = {}, this.fileChannels = {}, this.receiveFiles = {}, this.localSmallMediaStream = null, this.localSmallMediaTrack = null, this.bigStreamId = "", this.smallStreamId = "", this.audioStreamId = "", this.answerSDP = "", this.offerSDP = null, this.starPeerConnection = null, this.tempPC = null, this.callback = null, this.streamAllSetCallback = null, this.serverIp = "0.0.0.0", this.serverPort = 80, this.streamInfos = []
  }

  function a() {
    this.videoId = "", this.streamId = "", this.bigVideoSSRC = 0, this.smallVideoSSRC = 0, this.audioSSRC = 0, this.streamObj = null, this.switchFlag = !1
  }
  i.prototype.on = function (e, i) {
    this.events[e] = this.events[e] || [], this.events[e].push(i)
  }, i.prototype.emit = function (e, i) {
    var t, a, r = this.events[e],
      n = Array.prototype.slice.call(arguments, 1);
    if (r)
      for (t = 0, a = r.length; t < a; t++) r[t].apply(null, n)
  }, (t.prototype = new i).destroy = function () {
    this.emit("_remove_peer")
  }, t.prototype.resetStreamInfos = function (e) {
    this.streamInfos = [];
    for (var i = 0; i < 7; ++i) {
      var t = new a;
      t.bigVideoSSRC = 2312312300 + i, t.smallVideoSSRC = 2312311300 + i, t.audioSSRC = 2312310300 + i, t.streamId = this.createRandomString(u, 36), t.cname = this.createRandomString(u, 16), this.streamInfos.push(t)
    }
  }, t.prototype.init = function () {
    this.resetStreamInfos();
    var p = this;
    this.on("_peers", function (e) {
      p.connections = e.connections, p.me = e.you, p.emit("get_peers", p.connections)
    }), this.on("_remove_peer", function (e) {
      p.starPeerConnection && (p.closePeerConnection(p.starPeerConnection), delete p.starPeerConnection, p.starPeerConnection = null), p.tempPC && (p.closePeerConnection(p.tempPC), delete p.tempPC, p.tempPC = null), null != p.localMediaStream && (p.localMediaStream.getTracks().forEach(function (e) {
        e.stop()
      }), p.localMediaStream = null), null != p.localSmallMediaTrack && (p.localSmallMediaTrack.stop(), p.localSmallMediaTrack = null), null != p.localSmallMediaStream && (p.localSmallMediaStream.getTracks().forEach(function (e) {
        e.stop()
      }), p.localSmallMediaStream = null), p.bigStreamId = "", p.smallStreamId = "", p.audioStreamId = "", p.answerSDP = "", p.offerSDP = null, p.callback = null, p.serverIp = "0.0.0.0", p.serverPort = 80, p.resetStreamInfos()
    }), this.on("_offer", function (e) {
      p.receiveOffer(e.socketId, e.sdp), p.emit("get_offer", e)
    }), this.on("_answer", function (e) {
      var i = e.sessionDesc;
      i.type = "answer", i.sdp = i.sdp.replace(/actpass/g, "active"), p.receiveAnswer(e.socketId, i), p.emit("get_answer", e)
    }), this.on("_webrtc_apply_ok", function (e, i, t, a) {
      if (null == p.offerSDP) p.offerSDP = p.createDefaultSdpObj(t, a);
      else {
        var r = !1,
          n = !1;
        for (var s in p.offerSDP.mediaDesc) {
          var o = p.offerSDP.mediaDesc[s];
          "audio" == o.type ? n = !0 : "video" == o.type && (r = !0)
        }
        n || p.offerSDP.mediaDesc.push(p.createDefaultAudioMediaSdpObj(a)), r || p.offerSDP.mediaDesc.push(p.createDefaultVideoMediaSdpObj(t))
      }
      p.streamAllSetCallback = i;
      var c = "504457478 1 udp 2013266431 " + p.serverIp + " " + p.serverPort + " typ host generation 0 ufrag Nud3 network-id 1",
        d = sdpUtils.clone(p.offerSDP);
      "controlled" == m.iceControlRole ? "plan-b" == m.sdpSemantics ? p.createAnswerFromOfferPlanB(d, "Nud3", "SKuOCnwS3ScdasO5hD2aheqb", e, p.streamInfos, [c]) : p.createAnswerFromOfferUnifyPlan(d, "Nud3", "SKuOCnwS3ScdasO5hD2aheqb", e, p.streamInfos, [c]) : "plan-b" == m.sdpSemantics ? p.createAnswerFromOfferPlanB(d, "Nud3", "SKuOCnwS3ScdasO5hD2aheqb", e, p.streamInfos, [c]) : p.createAnswerFromOfferUnifyPlan2(d, "Nud3", "SKuOCnwS3ScdasO5hD2aheqb", e, p.streamInfos, [c]);
      var l = sdpUtils.genSdp(d),
        f = {};
      "controlled" == m.iceControlRole ? f.type = "offer" : f.type = "answer", f.sdp = l, p.starPeerConnection.setRemoteDescription(f).then(function () {
        "controlled" == m.iceControlRole ? p.starPeerConnection.createAnswer(function (e) {
          var i = sdpUtils.parseSdp(e.sdp);
          p.filterSdpObj(i), p.replaceData(i);
          var t = sdpUtils.genSdp(i);
          e.sdp = t, p.starPeerConnection.setLocalDescription(e).then(function () {
            p.callback({
              type: "applyAnswer",
              status: "success"
            })
          }, function (e) {
            console.error(e), p.callback({
              type: "applyAnswer",
              status: "failed"
            })
          })
        }, function (e) {
          console.error(e), p.callback({
            type: "applyAnswer",
            status: "failed"
          })
        }) : p.callback({
          type: "applyAnswer",
          status: "success"
        })
      }, function (e) {
        console.error(e), p.callback({
          type: "applyAnswer",
          status: "failed"
        })
      })
    }), this.on("ready", function (e, i) {
      var t = i || !1;
      p.callback = e, p.createPeerConnections(), p.addStreams(t), p.sendOffers()
    })
  }, t.prototype.createScreenCaptureStream = function (e, i, t) {
    var a = this;
    (function (e) {
      return navigator.getDisplayMedia ? navigator.getDisplayMedia({
        video: !0,
        audio: e.audio
      }) : navigator.mediaDevices.getDisplayMedia ? navigator.mediaDevices.getDisplayMedia({
        video: !0,
        audio: e.audio
      }) : navigator.mediaDevices.getUserMedia({
        video: {
          mediaSource: "screen"
        },
        audio: e.audio
      })
    })(e).then(function (e) {
      a.localMediaStream = e, a.localMediaStream && (a.localMediaStream.addEventListener("inactive", function (e) {
        console.warn("Capture stream inactive"), t(e)
      }), a.initializedStreams++), i("success", e)
    }).catch(function (e) {
      i("failed", e)
    })
  }, t.prototype.publishStream = function (i) {
    this.starPeerConnection && this.starPeerConnection.getSenders().forEach(function (e) {
      e.track && ("video" == e.track.kind && null != i.video ? e.track.enabled = i.video : "audio" == e.track.kind && null != i.audio && (e.track.enabled = i.audio))
    })
  }, t.prototype.createStream = function (n, i, t) {
    var a = this;
    n.video || n.audio ? navigator.mediaDevices.getUserMedia ? (this.numStreams++, navigator.mediaDevices.enumerateDevices().then(function (e) {
      for (var i = !1, t = !1, a = 0; a !== e.length; ++a) {
        var r = e[a];
        "audioinput" === r.kind ? i = !0 : "audiooutput" === r.kind || ("videoinput" === r.kind ? t = !0 : console.info("Some other kind of source/device: ", r))
      }
      return t || (n.video = !1), i || (n.audio = !1), n.video || n.audio ? navigator.mediaDevices.getUserMedia(n) : Promise.resolve(null)
    }).then(function (e) {
      a.localMediaStream = e, a.localMediaStream && (a.localMediaStream.addEventListener("inactive", function (e) {
        console.warn("Capture stream inactive"), t(e)
      }), a.initializedStreams++), i("success", e)
    }).catch(function (e) {
      i("failed", e)
    })) : i("failed", new Error("WebRTC is not yet supported in this browser.")) : i("success", null)
  }, t.prototype.addStreams = function (t) {
    if (null != this.localMediaStream) {
      var a = this,
        r = !1,
        n = null;
      window.RTCPeerConnection.prototype.addTrack && 65 <= s.version && (r = !0), r || t || (n = this.localMediaStream.clone()).getTracks().forEach(function (e) {
        e.stop(), n.removeTrack(e)
      }), this.localMediaStream.getTracks().forEach(function (e) {
        if (r && (a.starPeerConnection.addTrack(e, a.localMediaStream), "controlled" == m.iceControlRole && a.tempPC.addTrack(e, a.localMediaStream)), "video" == e.kind) {
          if (a.bigStreamId = e.id, !t) {
            var i = e.clone();
            a.localSmallMediaTrack = i, a.smallStreamId = i.id, MediaStreamTrack.prototype.applyConstraints && ("safari" != s.browser ? i.applyConstraints({
              width: {
                ideal: 120
              },
              height: {
                ideal: 90
              },
              facingMode: {
                ideal: ["user"]
              }
            }) : i.applyConstraints({
              width: {
                ideal: 640
              },
              height: {
                ideal: 480
              },
              facingMode: {
                ideal: ["user"]
              }
            })), r ? (a.starPeerConnection.addTrack(i, a.localMediaStream), "controlled" == m.iceControlRole && a.tempPC.addTrack(i, a.localMediaStream)) : n.addTrack(i)
          }
        } else "audio" == e.kind && (a.audioStreamId = e.id)
      }), r || (a.starPeerConnection.addStream(a.localMediaStream), "controlled" == m.iceControlRole && a.tempPC.addStream(a.localMediaStream), null != n && (a.starPeerConnection.addStream(n), "controlled" == m.iceControlRole && a.tempPC.addStream(n))), a.localSmallMediaStream = n
    }
  }, t.prototype.attachStream = function (e, i) {
    document.getElementById(i).srcObject = e
  }, t.prototype.switchStream = function (i) {
    var t = [];
    i.getVideoTracks().forEach(function (e) {
      t.push(e), i.removeTrack(e)
    });
    for (var e = t.length - 1; 0 <= e; e--) i.addTrack(t[e])
  }, t.prototype.switchStreamInfo = function (e) {
    e.switchFlag = !e.switchFlag, this.switchStream(e.streamObj)
  }, t.prototype.resetStreamInfo = function (e) {
    e.switchFlag && this.switchStreamInfo(e)
  }, t.prototype.switchStreams = function () {
    for (var e in this.streamInfos) this.switchStreamInfo(this.streamInfos[e])
  }, t.prototype.getStreamByIndex = function (e) {
    return this.streamInfos[e]
  }, t.prototype.getStreamInfos = function (e) {
    return this.streamInfos
  }, t.prototype.onAddStream = function (e) {
    var i = !0;
    for (var t in this.streamInfos) {
      var a = this.streamInfos[t];
      a.streamId == e.id && (a.streamObj = e), null == a.streamObj && (i = !1)
    }
    i && null != this.streamAllSetCallback && "connected" == this.starPeerConnection.iceConnectionState && (this.streamAllSetCallback(), this.streamAllSetCallback = null)
  }, t.prototype.setServerInfo = function (e) {
    this.serverIp = e.serverIp, this.serverPort = e.serverPort
  };
  var u = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    o = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
  return t.prototype.createRandomString = function (e, i) {
    for (var t = "", a = 0; a < i; ++a) t += e[Math.floor(Math.random() * e.length)];
    return t
  }, t.prototype.uuid = function () {
    function e() {
      return (65536 * (1 + Math.random()) | 0).toString(16).substring(1)
    }
    return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e()
  }, t.prototype.replaceData = function (e) {
    for (var i in "" == e.iceInfo.iceUfrag && "" != this.sdpData.iceUfrag && (e.iceInfo.iceUfrag = this.sdpData.iceUfrag, e.iceInfo.icePwd = this.sdpData.icePwd), e.mediaDesc) {
      var t = e.mediaDesc[i];
      if ("" != this.sdpData.iceUfrag && (t.iceInfo.iceUfrag = this.sdpData.iceUfrag, t.iceInfo.icePwd = this.sdpData.icePwd), "audio" == t.type) {
        if (t.msid && "" != t.msid) {
          if ("" != this.audioStreamId && -1 != t.msid.indexOf(this.audioStreamId)) {
            a = t.ssrcInfoArray[0];
            delete t.ssrcInfoMap[a.ssrc], a.ssrc = this.sdpData.audioSSRC, t.ssrcInfoMap[a.ssrc] = a
          }
        } else if ("" != this.audioStreamId)
          for (var i in t.ssrcInfoArray) {
            -1 != (a = t.ssrcInfoArray[i]).msid.indexOf(this.audioStreamId) && (delete t.ssrcInfoMap[a.ssrc], a.ssrc = this.sdpData.audioSSRC, t.ssrcInfoMap[a.ssrc] = a)
          }
      } else if ("video" == t.type)
        if (t.msid && "" != t.msid) {
          if ("" != this.smallStreamId && -1 != t.msid.indexOf(this.smallStreamId)) {
            a = t.ssrcInfoArray[0];
            delete t.ssrcInfoMap[a.ssrc], a.ssrc = this.sdpData.smallVideoSSRC, t.ssrcInfoMap[a.ssrc] = a
          } else if ("" != this.bigStreamId && -1 != t.msid.indexOf(this.bigStreamId)) {
            a = t.ssrcInfoArray[0];
            delete t.ssrcInfoMap[a.ssrc], a.ssrc = this.sdpData.bigVideoSSRC, t.ssrcInfoMap[a.ssrc] = a
          }
        } else
          for (var i in t.ssrcInfoArray) {
            var a = t.ssrcInfoArray[i];
            "" != this.smallStreamId && -1 != a.msid.indexOf(this.smallStreamId) ? (delete t.ssrcInfoMap[a.ssrc], a.ssrc = this.sdpData.smallVideoSSRC, t.ssrcInfoMap[a.ssrc] = a) : "" != this.bigStreamId && -1 != a.msid.indexOf(this.bigStreamId) && (delete t.ssrcInfoMap[a.ssrc], a.ssrc = this.sdpData.bigVideoSSRC, t.ssrcInfoMap[a.ssrc] = a)
          }
    }
  }, t.prototype.filterSdpObj = function (e) {
    for (var i in e.mediaDesc) {
      var t = e.mediaDesc[i];
      t.extmap = {}, t.ssrcGroup = [], t.codecInfoMap = {};
      var a = [];
      for (var i in t.codecInfoArray) {
        var r = t.codecInfoArray[i];
        "audio" == t.type ? "opus" == r.codecName && (a.push(r), t.codecInfoMap[r.payload] = r) : "video" == t.type && "H264" == r.codecName && 0 == a.length && (a.push(r), t.codecInfoMap[r.payload] = r)
      }
      t.codecInfoArray = a;
      var n = {},
        s = [],
        o = {};
      for (var i in t.ssrcInfoArray) {
        var c = t.ssrcInfoArray[i];
        null == o[c.label] && (o[c.label] = 1, n[c.ssrc] = c, s.push(c))
      }
      t.ssrcInfoArray = s, t.ssrcInfoMap = n
    }
  }, t.prototype.getSdpData = function (e, i) {
    var t = {
      audioSSRC: "",
      smallVideoSSRC: "",
      bigVideoSSRC: "",
      audioCodec: "0",
      videoCodec: "0",
      iceUfrag: "",
      icePwd: ""
    };
    for (var a in t.iceUfrag = e.iceInfo.iceUfrag, t.icePwd = e.iceInfo.icePwd, e.mediaDesc) {
      var r = e.mediaDesc[a];
      if ("" == t.iceUfrag && (t.iceUfrag = r.iceInfo.iceUfrag, t.icePwd = r.iceInfo.icePwd), "recvonly" != r.commAbility)
        if ("audio" == r.type) {
          for (var n in r.ssrcInfoMap) {
            var s = r.ssrcInfoMap[n];
            t.audioSSRC = s.ssrc
          }
          t.audioCodec = r.codecInfoArray[0].payload
        } else if ("video" == r.type) {
        for (var n in r.ssrcInfoMap) {
          s = r.ssrcInfoMap[n];
          "" != i.bigStreamId && (0 == s.label.length ? -1 != r.msid.indexOf(i.bigStreamId) && (t.bigVideoSSRC = s.ssrc) : -1 != s.label.indexOf(i.bigStreamId) && (t.bigVideoSSRC = s.ssrc)), "" != i.smallStreamId && (0 == s.label.length ? -1 != r.msid.indexOf(i.smallStreamId) && (t.smallVideoSSRC = s.ssrc) : -1 != s.label.indexOf(i.smallStreamId) && (t.smallVideoSSRC = s.ssrc))
        }
        "" == t.bigVideoSSRC && "" != i.bigStreamId ? 0 != r.ssrcInfoArray.length && (t.bigVideoSSRC = r.ssrcInfoArray[0].ssrc) : "" == t.smallVideoSSRC && "" != i.smallStreamId && 0 != r.ssrcInfoArray.length && (t.smallVideoSSRC = r.ssrcInfoArray[0].ssrc), t.videoCodec = r.codecInfoArray[0].payload
      }
    }
    return t
  }, t.prototype.createDefaultVideoMediaSdpObj = function (e) {
    e = e || 102;
    var i = new MediaDesc;
    i.mid = "video", i.type = "video", i.rtcpResize = !0, i.fingerprintInfo.algorithm = "sha-256", i.iceInfo.iceOptions = "trickle";
    var t = new CodecInfo;
    return t.payload = e, t.codecName = "H264", t.codecInterval = "90000", t.fmtp = ["level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f"], t.rtcpFB = ["goog-remb", "transport-cc", "ccm fir", "nack", "nack pli"], i.codecInfoArray = [t], i.codecInfoMap[t.payload] = t, i
  }, t.prototype.createDefaultAudioMediaSdpObj = function (e) {
    e = e || 111;
    var i = new MediaDesc;
    i.mid = "audio", i.type = "audio", i.fingerprintInfo.algorithm = "sha-256", i.iceInfo.iceOptions = "trickle";
    var t = new CodecInfo;
    return t.payload = e, t.codecName = "opus", t.codecInterval = "48000/2", t.fmtp = ["minptime=10;useinbandfec=1"], t.rtcpFB = ["transport-cc"], i.codecInfoArray = [t], i.codecInfoMap[t.payload] = t, i
  }, t.prototype.createDefaultSdpObj = function (e, i) {
    var t = new SdpDesc;
    return t.mediaDesc = [this.createDefaultAudioMediaSdpObj(i), this.createDefaultVideoMediaSdpObj(e)], t
  }, t.prototype.createAnswerFromOfferUnifyPlan = function (e, i, t, a, r, n) {
    "" != e.iceInfo.iceUfrag && (e.iceInfo.iceUfrag = i), "" != e.iceInfo.icePwd && (e.iceInfo.icePwd = t), e.iceInfo.iceLite = !0, "" != e.fingerprintInfo.algorithm && (e.fingerprintInfo.value = a);
    var s = !1,
      o = !1,
      c = [];
    for (var d in e.mediaDesc) {
      var l = e.mediaDesc[d];
      if (l.setup = "actpass", l.iceInfo.iceUfrag = i, l.iceInfo.icePwd = t, l.iceInfo.iceLite = !0, "" != l.fingerprintInfo.algorithm && (l.fingerprintInfo.value = a), l.candidate = n, l.ssrcInfoMap = {}, l.ssrcInfoArray = [], l.ssrcGroup = [], l.msid = "", "audio" != l.type || s) {
        if ("video" == l.type && !o)
          for (var f in o = !0, r) {
            var p, m;
            if (0 != r[f].smallVideoSSRC)(p = sdpUtils.clone(l)).mid = l.type + "_s" + d + "_" + f, (m = {}).ssrc = r[f].smallVideoSSRC, m.cname = r[f].cname, m.mslabel = r[f].streamId, m.label = this.uuid(), m.msid = m.mslabel + " " + m.label, p.ssrcInfoMap[m.ssrc] = m, p.ssrcInfoArray.push(m), p.msid = m.mslabel + " " + m.label, c.push(p);
            if (0 != r[f].bigVideoSSRC)(p = sdpUtils.clone(l)).mid = l.type + "_b" + d + "_" + f, (m = {}).ssrc = r[f].bigVideoSSRC, m.cname = r[f].cname, m.mslabel = r[f].streamId, m.label = this.uuid(), m.msid = m.mslabel + " " + m.label, p.ssrcInfoMap[m.ssrc] = m, p.msid = m.mslabel + " " + m.label, p.ssrcInfoArray.push(m), c.push(p)
          }
      } else
        for (var f in s = !0, r) {
          var u = sdpUtils.clone(l);
          u.mid = l.type + "_" + d + "_" + f;
          var h = {};
          h.ssrc = r[f].audioSSRC, h.cname = r[f].cname, h.mslabel = r[f].streamId, h.label = this.uuid(), h.msid = h.mslabel + " " + h.label, u.ssrcInfoMap[h.ssrc] = h, u.ssrcInfoArray.push(h), u.msid = h.mslabel + " " + h.label, c.push(u)
        }
    }
    e.mediaDesc = c
  }, t.prototype.createAnswerFromOfferUnifyPlan2 = function (e, i, t, a, r, n) {
    "" != e.iceInfo.iceUfrag && (e.iceInfo.iceUfrag = i), "" != e.iceInfo.icePwd && (e.iceInfo.icePwd = t), e.iceInfo.iceLite = !0, "" != e.fingerprintInfo.algorithm && (e.fingerprintInfo.value = a);
    var s = 0,
      o = 0,
      c = 0;
    for (var d in e.mediaDesc) {
      var l = e.mediaDesc[d];
      if ("actpass" == l.setup ? l.setup = "passive" : l.setup = "actpass", l.iceInfo.iceUfrag = i, l.iceInfo.icePwd = t, l.iceInfo.iceLite = !0, "" != l.fingerprintInfo.algorithm && (l.fingerprintInfo.value = a), l.candidate = n, l.ssrcInfoMap = {}, l.ssrcInfoArray = [], l.ssrcGroup = [], l.msid = "", "recvonly" == l.commAbility) {
        var f, p = {};
        "audio" == l.type ? (f = s, p.ssrc = r[f].audioSSRC, s++) : "video" == l.type && (o < c ? (f = o, p.ssrc = r[f].bigVideoSSRC, o++) : (f = c, p.ssrc = r[f].smallVideoSSRC, c++)), p.cname = r[f].cname, p.mslabel = r[f].streamId, p.label = this.uuid(), p.msid = p.mslabel + " " + p.label, l.ssrcInfoMap[p.ssrc] = p, l.ssrcInfoArray.push(p), l.msid = p.mslabel + " " + p.label, l.commAbility = "sendonly"
      }
    }
  }, t.prototype.createAnswerFromOfferPlanB = function (e, i, t, a, r, n) {
    var s = this.createRandomString(u, 16);
    "" != e.iceInfo.iceUfrag && (e.iceInfo.iceUfrag = i), "" != e.iceInfo.icePwd && (e.iceInfo.icePwd = t), e.iceInfo.iceLite = !0, "" != e.fingerprintInfo.algorithm && (e.fingerprintInfo.value = a);
    var o = [],
      c = !1,
      d = !1;
    for (var l in e.mediaDesc) {
      var f = e.mediaDesc[l];
      if (f.setup = "actpass", f.iceInfo.iceUfrag = i, f.iceInfo.icePwd = t, f.iceInfo.iceLite = !0, "" != f.fingerprintInfo.algorithm && (f.fingerprintInfo.value = a), f.candidate = n, f.ssrcInfoMap = {}, f.ssrcInfoArray = [], f.ssrcGroup = [], f.msid = "", "audio" != f.type || c) {
        if ("video" == f.type && !d) {
          for (var l in d = !0, r) {
            var p;
            if (0 != r[l].smallVideoSSRC)(p = {}).ssrc = r[l].smallVideoSSRC, p.cname = s, p.mslabel = r[l].streamId, p.label = this.uuid(), p.msid = p.mslabel + " " + p.label, f.ssrcInfoMap[p.ssrc] = p, f.ssrcInfoArray.push(p);
            if (0 != r[l].bigVideoSSRC)(p = {}).ssrc = r[l].bigVideoSSRC, p.cname = s, p.mslabel = r[l].streamId, p.label = this.uuid(), p.msid = p.mslabel + " " + p.label, f.ssrcInfoMap[p.ssrc] = p, f.ssrcInfoArray.push(p)
          }
          o.push(f)
        }
      } else {
        for (var l in c = !0, r) {
          var m = {};
          m.ssrc = r[l].audioSSRC, m.cname = s, m.mslabel = r[l].streamId, m.label = this.uuid(), m.msid = m.mslabel + " " + m.label, f.ssrcInfoMap[m.ssrc] = m, f.ssrcInfoArray.push(m)
        }
        o.push(f)
      }
    }
    e.mediaDesc = o
  }, t.prototype.addTransceiverForOffer = function (e, i) {
    for (var t in i) e.addTransceiver("audio", {
      direction: "recvonly"
    }), e.addTransceiver("video", {
      direction: "recvonly"
    }), e.addTransceiver("video", {
      direction: "recvonly"
    })
  }, t.prototype.sendOffers = function () {
    if (null == this.localMediaStream && "controlled" == m.iceControlRole) return this.sdpData = {
      audioSSRC: "",
      smallVideoSSRC: "",
      bigVideoSSRC: "",
      audioCodec: "0",
      videoCodec: "0",
      iceUfrag: this.createRandomString(o, 4),
      icePwd: this.createRandomString(o, 24)
    }, void this.callback({
      type: "createOffer",
      status: "success",
      audioSSRC: this.sdpData.audioSSRC,
      smallVideoSSRC: this.sdpData.smallVideoSSRC,
      bigVideoSSRC: this.sdpData.bigVideoSSRC,
      videoCodec: this.sdpData.videoCodec,
      audioCodec: this.sdpData.audioCodec,
      iceUfrag: this.sdpData.iceUfrag,
      icePwd: this.sdpData.icePwd
    });
    var e, r, n, s = this;
    "controlled" == m.iceControlRole ? e = this.tempPC : (e = this.starPeerConnection, "unified-plan" == m.sdpSemantics && this.addTransceiverForOffer(e, this.streamInfos)), e.createOffer((r = e, n = this.callback, function (e) {
      var i = sdpUtils.parseSdp(e.sdp);
      s.filterSdpObj(i);
      var t = sdpUtils.genSdp(i);
      s.offerSDP = i, e.sdp = t;
      var a = s.getSdpData(i, {
        bigStreamId: s.bigStreamId,
        smallStreamId: s.smallStreamId
      });
      s.sdpData = a, "controlled" == m.iceControlRole ? (s.tempPC.close(), delete s.tempPC, s.tempPC = null, n({
        type: "createOffer",
        status: "success",
        audioSSRC: a.audioSSRC,
        smallVideoSSRC: a.smallVideoSSRC,
        bigVideoSSRC: a.bigVideoSSRC,
        videoCodec: a.videoCodec,
        audioCodec: a.audioCodec,
        iceUfrag: a.iceUfrag,
        icePwd: a.icePwd
      })) : r.setLocalDescription(e).then(function () {
        n({
          type: "createOffer",
          status: "success",
          audioSSRC: a.audioSSRC,
          smallVideoSSRC: a.smallVideoSSRC,
          bigVideoSSRC: a.bigVideoSSRC,
          videoCodec: a.videoCodec,
          audioCodec: a.audioCodec,
          iceUfrag: a.iceUfrag,
          icePwd: a.icePwd
        })
      }, function (e) {
        n({
          type: "createOffer",
          status: "failed",
          audioSSRC: a.audioSSRC,
          smallVideoSSRC: a.smallVideoSSRC,
          bigVideoSSRC: a.bigVideoSSRC,
          videoCodec: a.videoCodec,
          audioCodec: a.audioCodec,
          iceUfrag: a.iceUfrag,
          icePwd: a.icePwd
        })
      })
    }), function (e) {
      console.error(e), s.callback({
        type: "createOffer",
        status: "failed"
      })
    })
  }, t.prototype.receiveOffer = function (e, i) {
    this.starPeerConnection;
    this.sendAnswer(e, i)
  }, t.prototype.sendAnswer = function (i, e) {
    var t = this.starPeerConnection,
      a = this;
    t.setRemoteDescription(new r(e)), t.createAnswer(function (e) {
      t.setLocalDescription(e), a.socket.send(JSON.stringify({
        eventName: "__answer",
        data: {
          socketId: i,
          sdp: e
        }
      }))
    }, function (e) {
      console.error(e)
    })
  }, t.prototype.receiveAnswer = function (e, i) {
    var t = this.starPeerConnection,
      a = this;
    t.setRemoteDescription(new r(i)).then(function () {
      a.callback({
        type: "applyAnswer",
        status: "success"
      })
    }, function (e) {
      a.callback({
        type: "applyAnswer",
        status: "failed"
      })
    })
  }, t.prototype.createPeerConnections = function () {
    this.createPeerConnection("xuaisi")
  }, t.prototype.createPeerConnection = function (e) {
    var a = this,
      r = new n(m);
    return this.starPeerConnection && (this.closePeerConnection(this.starPeerConnection), delete this.starPeerConnection, this.starPeerConnection = null), this.tempPC && (this.closePeerConnection(this.tempPC), delete this.tempPC, this.tempPC = null), this.starPeerConnection = r, null != this.localMediaStream && "controlled" == m.iceControlRole && (this.tempPC = new n(m)), r.onicecandidate = function (e) {}, r.oniceconnectionstatechange = function (e) {
      if (console.log("oniceconnectionstatechange:" + r.iceConnectionState), "connected" === r.iceConnectionState && null != a.streamAllSetCallback) {
        var i = !0;
        for (var t in a.streamInfos) {
          null == a.streamInfos[t].streamObj && (i = !1)
        }
        i && (a.streamAllSetCallback(), a.streamAllSetCallback = null)
      }
    }, r.onconnectionstatechange = function (e) {
      if (console.log("onconnectionstatechange:" + r.connectionState), "connected" === r.connectionState && null != a.streamAllSetCallback) {
        var i = !0;
        for (var t in a.streamInfos) {
          null == a.streamInfos[t].streamObj && (i = !1)
        }
        i && (a.streamAllSetCallback(), a.streamAllSetCallback = null)
      }
    }, r.onopen = function () {
      console.log("pc onopen")
    }, r.onaddstream = function (e) {
      a.onAddStream(e.stream)
    }, r.ondatachannel = function (e) {}, r
  }, t.prototype.closePeerConnection = function (e) {
    e && e.close()
  }, t.prototype.broadcast = function (e) {
    var i;
    for (i in this.dataChannels) this.sendMessage(e, i)
  }, t.prototype.sendMessage = function (e, i) {
    "open" === this.dataChannels[i].readyState.toLowerCase() && this.dataChannels[i].send(JSON.stringify({
      type: "__msg",
      data: e
    }))
  }, t.prototype.addDataChannels = function () {
    var e;
    for (e in this.peerConnections) this.createDataChannel(e)
  }, t.prototype.createDataChannel = function (i, e) {
    var t, a;
    t = this.peerConnections[i], i || this.emit("data_channel_create_error", i, new Error("attempt to create data channel without socket id")), t instanceof n || this.emit("data_channel_create_error", i, new Error("attempt to create data channel without peerConnection"));
    try {
      a = t.createDataChannel(e)
    } catch (e) {
      this.emit("data_channel_create_error", i, e)
    }
    return this.addDataChannel(i, a)
  }, t.prototype.addDataChannel = function (t, a) {
    var r = this;
    return a.onopen = function () {
      r.emit("data_channel_opened", a, t)
    }, a.onclose = function (e) {
      delete r.dataChannels[t], r.emit("data_channel_closed", a, t)
    }, a.onmessage = function (e) {
      var i;
      "__file" === (i = JSON.parse(e.data)).type ? r.parseFilePacket(i, t) : r.emit("data_channel_message", a, t, i.data)
    }, a.onerror = function (e) {
      r.emit("data_channel_error", a, t, e)
    }, this.dataChannels[t] = a
  }, new t
};

if (void 0 === APP_PRODUCT_ID) var i = 0,
  APP_PRODUCT_ID = {
    t: i++,
    R: i++,
    O: i++,
    _: i++,
    s: i++,
    S: i++,
    i: i++,
    I: i++,
    o: i++,
    A: i++,
    N: i++
  };
if (void 0 === ACTION_GROUP_ID) {
  i = 0;
  var ACTION_GROUP_ID = {
    M: i++,
    V: i++,
    u: i++,
    C: i++,
    T: i++,
    P: i++
  }
}
if (void 0 === MSG_TYPE) {
  i = 0;
  var MSG_TYPE = {
    L: i++,
    G: i++,
    l: i++,
    D: i++,
    p: i++
  }
}
if (void 0 === MSG_DATA_TYPE) {
  i = 0;
  var MSG_DATA_TYPE = {
    U: i++,
    v: i++,
    H: i++,
    k: i++
  }
}
if (void 0 === ENCRYPT_TYPE) {
  i = 0;
  var ENCRYPT_TYPE = {
    m: i++,
    g: i++
  }
}
if (void 0 === AG_MSG_VOIP_CTRL) var AG_MSG_VOIP_CTRL = {
  h: 1e3,
  Y: 1100,
  F: 1001,
  K: 1002,
  W: 1003,
  B: 1004
};
if (void 0 === CHATROOM_LIST_TYPE) {
  i = 0;
  var CHATROOM_LIST_TYPE = {
    CHATROOM_LIST_TYPE_CHATROOM: i++,
    CHATROOM_LIST_TYPE_LIVE: i++,
    CHATROOM_LIST_TYPE_LIVE_PUSH: i++,
    CHATROOM_LIST_TYPE_MEETING: i++,
    CHATROOM_LIST_TYPE_MEETING_PUSH: i++,
    CHATROOM_LIST_TYPE_CLASS: i++,
    CHATROOM_LIST_TYPE_CLASS_PUSH: i++,
    CHATROOM_LIST_TYPE_AUDIO_LIVE: i++,
    CHATROOM_LIST_TYPE_AUDIO_LIVE_PUSH: i++,
    CHATROOM_LIST_TYPE_SUPER_ROOM: i++,
    CHATROOM_LIST_TYPE_SUPER_ROOM_PUSH: i++
  }
}
if (StarRtc.CHATROOM_LIST_TYPE = CHATROOM_LIST_TYPE, void 0 === LOG_LEVEL) {
  i = 0;
  var LOG_LEVEL = {
    LOG_LEVEL_DEBUG: i++,
    LOG_LEVEL_INFO: i++,
    LOG_LEVEL_WARN: i++,
    LOG_LEVEL_ERROR: i++
  }
}
if (StarRtc.LOG_LEVEL = LOG_LEVEL, StarRtc.logLevel = LOG_LEVEL.LOG_LEVEL_DEBUG, StarRtc.noop = function () {},
  StarRtc.InitlogLevel = function (e) {
    switch (StarRtc.debug = StarRtc.noop, StarRtc.info = StarRtc.noop, StarRtc.warn = StarRtc.noop, StarRtc.error = StarRtc.noop, e) {
      case LOG_LEVEL.LOG_LEVEL_DEBUG:
        StarRtc.debug = console.log.bind(console);
      case LOG_LEVEL.LOG_LEVEL_INFO:
        StarRtc.info = console.log.bind(console);
      case LOG_LEVEL.LOG_LEVEL_WARN:
        StarRtc.warn = console.warn.bind(console);
      case LOG_LEVEL.LOG_LEVEL_ERROR:
        StarRtc.error = console.error.bind(console)
    }
    StarRtc.logLevel = e
  },
  StarRtc.InitlogLevel(StarRtc.logLevel), void 0 === AG_MSG) {
  i = 0;
  var AG_MSG = {
    q: i++,
    J: i++,
    j: i++,
    X: i++,
    Z: i++,
    $: i++,
    ee: i++,
    te: i++,
    Re: i++,
    ae: i++,
    Oe: i++,
    Ee: i++,
    _e: i++,
    re: i++,
    ne: i++,
    se: i++,
    ce: i++,
    Se: i++,
    ie: i++,
    Ie: i++,
    oe: i++,
    Ae: i++,
    Ne: i++,
    Me: i++,
    Ve: i++,
    ue: i++,
    Ce: i++,
    Te: i++,
    Pe: i++,
    Le: i++,
    Ge: i++,
    le: i++,
    fe: i++,
    De: i++,
    pe: i++,
    Ue: i++,
    de: i++,
    ve: i++,
    be: i++,
    He: i++,
    ke: i++,
    me: i++,
    ge: i++,
    we: i++,
    ye: i++
  }
}
if (void 0 === CHAT_ROOM_TYPE) {
  i = 1;
  var CHAT_ROOM_TYPE = {
    he: i++,
    xe: i++
  }
}
if (void 0 === AG_CHATROOMMOONSERVER) {
  i = 0;
  var AG_CHATROOMMOONSERVER = {
    Ye: i++,
    Fe: i++,
    Ke: i++,
    We: i++,
    Be: i++,
    qe: i++,
    Je: i++,
    Qe: i++,
    je: i++,
    Xe: i++,
    ze: i++,
    Ze: i++,
    $e: i++,
    et: i++,
    tt: i++,
    Rt: i++,
    at: i++,
    Ot: i++,
    Et: i++,
    _t: i++,
    rt: i++,
    nt: i++,
    st: i++,
    ct: i++,
    St: i++,
    it: i++,
    It: i++,
    ot: i++,
    At: i++,
    Nt: i++,
    Mt: i++,
    Vt: i++,
    ut: i++,
    Ct: i++,
    Tt: i++,
    Pt: i++,
    Lt: i++,
    Gt: i++,
    lt: i++,
    ft: i++,
    Dt: i++,
    pt: i++,
    Ut: i++,
    dt: i++,
    vt: i++
  }
}
if (void 0 === AG_VOIPMOONSERVER) {
  i = 0;
  var AG_VOIPMOONSERVER = {
    bt: i++,
    Ht: i++,
    kt: i++,
    gt: i++,
    wt: i++,
    yt: i++,
    ht: i++,
    xt: i++,
    Yt: i++,
    Ft: i++,
    Kt: i++,
    Wt: i++,
    Bt: i++,
    qt: i++,
    Jt: i++,
    Qt: i++,
    jt: i++,
    Xt: i++,
    zt: i++,
    Zt: i++,
    $t: i++,
    eR: i++,
    tR: i++,
    RR: i++,
    aR: i++,
    OR: i++,
    ER: i++,
    _R: i++,
    rR: i++,
    nR: i++,
    sR: i++,
    cR: i++,
    SR: i++,
    iR: i++,
    IR: i++,
    oR: i++,
    AR: i++,
    NR: i++,
    MR: i++
  }
}
if (void 0 === AG_LIVESRCMOONSERVER) {
  i = 0;
  var AG_LIVESRCMOONSERVER = {
    VR: i++,
    uR: i++,
    CR: i++,
    TR: i++,
    PR: i++,
    LR: i++,
    GR: i++,
    lR: i++,
    fR: i++,
    DR: i++,
    pR: i++,
    UR: i++,
    dR: i++,
    vR: i++,
    bR: i++,
    HR: i++,
    kR: i++,
    mR: i++,
    gR: i++,
    wR: i++,
    yR: i++,
    hR: i++,
    xR: i++,
    YR: i++,
    FR: i++,
    KR: i++,
    WR: i++,
    BR: i++,
    qR: i++,
    JR: i++,
    QR: i++,
    jR: i++,
    XR: i++,
    zR: i++,
    ZR: i++,
    $R: i++,
    ea: i++,
    ta: i++,
    Ra: i++,
    aa: i++,
    Oa: i++,
    Ea: i++,
    _a: i++,
    ra: i++,
    na: i++,
    sa: i++,
    ca: i++,
    Sa: i++,
    ia: i++,
    Ia: i++,
    oa: i++,
    Aa: i++,
    Na: i++,
    Ma: i++,
    Va: i++,
    ua: i++,
    Ca: i++,
    Ta: i++,
    Pa: i++,
    La: i++,
    Ga: i++,
    la: i++,
    fa: i++,
    Da: i++,
    pa: i++,
    Ua: i++,
    da: i++,
    va: i++,
    ba: i++,
    Ha: i++,
    ka: i++,
    ma: i++,
    ga: i++,
    wa: i++,
    ya: i++,
    ha: i++,
    xa: i++,
    Ya: i++,
    Fa: i++
  }
}
if (void 0 === AG_LIVEVDNMOONSERVER) {
  i = 0;
  var AG_LIVEVDNMOONSERVER = {
    Ka: i++,
    Wa: i++,
    Ba: i++,
    qa: i++,
    Ja: i++,
    Qa: i++,
    ja: i++,
    Xa: i++,
    za: i++,
    Za: i++,
    $a: i++,
    eO: i++,
    tO: i++,
    RO: i++,
    aO: i++,
    OO: i++,
    EO: i++,
    _O: i++,
    rO: i++,
    nO: i++,
    sO: i++,
    cO: i++,
    SO: i++,
    iO: i++
  }
}

function clone(e) {
  if (null == e || "object" != typeof e) return e;
  if (e instanceof Date) return (t = new Date).setTime(e.getTime()),
    t;
  if (e instanceof Array) {
    for (var t = [], R = e.length, a = 0; a < R; ++a) t[a] = clone(e[a]);
    return t
  }
  if (e instanceof Object) {
    t = {};
    for (var O in e) e.hasOwnProperty(O) && (t[O] = clone(e[O]));
    return t
  }
  throw new Error("Unable to copy obj! Its type isn't supported.")
}
StarRtc.AUtils = new

function () {
  var e = this;

  function L(e, t) {
    for (var R = q(e), a = J(w(R.length.toString(16))), O = q(t), E = J(w(O.length.toString(16))), _ = new Uint8Array(R.length + O.length + 8), r = 0, n = a.length, s = r; s < n; s++) _[s] = a[s - r];
    n = (r = n) + R.length;
    for (s = r; s < n; s++) _[s] = R[s - r];
    n = (r = n) + E.length;
    for (s = r; s < n; s++) _[s] = E[s - r];
    n = (r = n) + O.length;
    for (s = r; s < n; s++) _[s] = O[s - r];
    return _
  }

  function k(e) {
    var t = new Uint8Array(e),
      R = 0,
      a = parseInt("0x" + g(t.slice(R, R + 4)));
    R += 4;
    var O = m(t.slice(R, R + a));
    R += a;
    var E = parseInt("0x" + g(t.slice(R, R + 4)));
    return R += 4, {
      digest: O,
      content: m(t.slice(R, R + E))
    }
  }

  function w(e) {
    var t = 8 - e.length;
    return "00000000".substr(0, t) + e
  }

  function W(e) {
    var t = 4 - e.length;
    return "0000".substr(0, t) + e
  }

  function B(e, t) {
    var R = new Array(e + 1).join("0"),
      a = e - t.length;
    return R.substr(0, a) + t
  }

  function q(e) {
    var t, R, a = new Array;
    t = e.length;
    for (var O = 0; O < t; O++) 65536 <= (R = e.charCodeAt(O)) && R <= 1114111 ? (a.push(R >> 18 & 7 | 240), a.push(R >> 12 & 63 | 128), a.push(R >> 6 & 63 | 128), a.push(63 & R | 128)) : 2048 <= R && R <= 65535 ? (a.push(R >> 12 & 15 | 224), a.push(R >> 6 & 63 | 128), a.push(63 & R | 128)) : 128 <= R && R <= 2047 ? (a.push(R >> 6 & 31 | 192), a.push(63 & R | 128)) : a.push(255 & R);
    return a
  }

  function m(e) {
    if ("string" == typeof e) return e;
    for (var t = "",
        R = e,
        a = 0; a < R.length; a++) {
      var O = R[a].toString(2),
        E = O.match(/^1+?(?=0)/);
      if (E && 8 == O.length) {
        for (var _ = E[0].length, r = R[a].toString(2).slice(7 - _), n = 1; n < _; n++) r += R[n + a].toString(2).slice(2);
        t += String.fromCharCode(parseInt(r, 2)),
          a += _ - 1
      } else t += String.fromCharCode(R[a])
    }
    return t
  }

  function J(e) {
    var t = 0,
      R = e.length;
    if (R % 2 != 0) return null;
    R /= 2;
    for (var a = new Array,
        O = 0; O < R; O++) {
      var E = e.substr(t, 2),
        _ = parseInt("0x" + E);
      a.push(_),
        t += 2
    }
    return a
  }

  function g(e) {
    for (var t = "",
        R = 0; R < e.length; R++) {
      var a = e[R].toString(16);
      1 == a.length && (a = "0" + a),
        t += a
    }
    return t
  }

  function Q(e, t, R) {
    var a = t;
    for (var O in R)
      for (var E = R[O], _ = 0; _ < E.length; _++, a++) e[a] = E[_]
  }
  e.parseProtocol = function (e, c) {
      var t = new Blob([e], {
          type: "text/plain"
        }),
        S = new FileReader;
      S.readAsArrayBuffer(t),
        S.onload = function (e) {
          var t = new Uint8Array(S.result);
          StarRtc.debug("parseProtocol:", t);
          var R = t[0],
            a = t.slice(1, 5),
            O = t[5],
            E = t.slice(6, 8),
            _ = t.slice(8, 10),
            r = t[10],
            n = t.slice(11, t.byteLength - 2);
          StarRtc.debug("parseProtocol: msgArr = ", n);
          var s = t.slice(t.byteLength - 2, t.byteLength);
          c({
            appid: R,
            plength: a,
            appver: O,
            rese1: E,
            rese2: _,
            actionid: r,
            msgArr: n,
            end: s
          })
        }
    },
    e.packageProtocol = function (e, t, R) {
      var a = e,
        O = new Array(255, 255),
        E = new Array(255, 255),
        _ = t,
        r = (new Array(18, 52), R),
        n = new Uint8Array(r),
        s = J(w((r.byteLength + 12).toString(16))),
        c = new ArrayBuffer(r.byteLength + 13),
        S = new Uint8Array(c);
      S[0] = a;
      for (var i = 1; i < 5; i++) S[i] = s[i - 1];
      S[5] = 2,
        S[6] = O[0],
        S[7] = O[1],
        S[8] = E[0],
        S[9] = E[1],
        S[10] = _;
      for (i = 11; i < 11 + n.byteLength; i++) S[i] = n[i - 11];
      return S[11 + n.byteLength] = 18,
        S[12 + n.byteLength] = 52,
        StarRtc.debug("packageProtocol", S),
        S
    },
    e.constructAuthMsg = function (e) {
      e.agentId,
        e.userId;
      for (var t = e.starUid,
          R = e.starToken,
          a = J(W(AG_MSG.q.toString(16))), O = q(t), E = J(W(O.length.toString(16))), _ = q(R), r = new Uint8Array(O.length + 36), n = 0, s = a.length, c = n; c < s; c++) r[c] = a[c];
      s = (n = s) + E.length;
      for (c = n; c < s; c++) r[c] = E[c - n];
      s = (n = s) + O.length;
      for (c = n; c < s; c++) r[c] = O[c - n];
      s = (n = s) + _.length;
      for (c = n; c < s; c++) r[c] = _[c - n];
      n = 0;
      var S = [];
      return S.push(a),
        S.push(E),
        S.push(O),
        S.push(_),
        Q(r, n, S),
        r
    },
    e.constructMsgProtocol = function (e, t, R) {
      R.agentId,
        R.userId;
      var a, O = R.starUid,
        E = R.starToken,
        _ = [],
        r = J(W(e.toString(16))),
        n = q(O),
        s = J(W(n.length.toString(16)));
      J(W(q(E).length.toString(16)));
      switch (e) {
        case AG_MSG.ee:
          var c = J(w(t.reqIndex.toString(16))),
            S = J(w((o = q(t.addUsers)).length.toString(16))),
            i = J(w((A = q(t.userDefineData)).length.toString(16)));
          a = new Uint8Array(6 + (2 + n.length) + (4 + o.length) + (4 + A.length)),
            _.push(r),
            _.push(c),
            _.push(s),
            _.push(n),
            _.push(S),
            _.push(o),
            _.push(i),
            _.push(A);
          break;
        case AG_MSG.te:
          c = J(w(t.reqIndex.toString(16)));
          var I = J(W((V = q(R.agentId + "_" + t.groupId)).length.toString(16)));
          a = new Uint8Array(6 + (2 + V.length) + (2 + n.length)),
            _.push(r),
            _.push(c),
            _.push(I),
            _.push(V),
            _.push(s),
            _.push(n);
          break;
        case AG_MSG.Re:
          var o;
          c = J(w(t.reqIndex.toString(16))),
            I = J(W((V = q(R.agentId + "_" + t.groupId)).length.toString(16))),
            S = J(w((o = q(t.addUsers)).length.toString(16))),
            i = J(w((A = q(t.userDefineData)).length.toString(16)));
          a = new Uint8Array(6 + (2 + V.length) + (2 + n.length) + (4 + o.length) + (4 + A.length)),
            _.push(r),
            _.push(c),
            _.push(I),
            _.push(V),
            _.push(s),
            _.push(n),
            _.push(S),
            _.push(o),
            _.push(i),
            _.push(A);
          break;
        case AG_MSG.ae:
          c = J(w(t.reqIndex.toString(16))),
            I = J(W((V = q(R.agentId + "_" + t.groupId)).length.toString(16)));
          var A, N = q(t.removeUsers),
            M = J(w(N.length.toString(16)));
          //i = J(w((A = q(t.userDefineData)).length.toString(16)));
          a = new Uint8Array(6 + (2 + V.length) + (2 + n.length) + (4 + N.length)),
            _.push(r),
            _.push(c),
            _.push(I),
            _.push(V),
            _.push(s),
            _.push(n),
            _.push(M),
            _.push(N);
          break;
        case AG_MSG.Oe:
        case AG_MSG.Ee:
          c = J(w(t.reqIndex.toString(16))),
            I = J(W((V = q(R.agentId + "_" + t.groupId)).length.toString(16)));
          a = new Uint8Array(6 + (2 + V.length) + (2 + n.length)),
            _.push(r),
            _.push(c),
            _.push(I),
            _.push(V),
            _.push(s),
            _.push(n);
          break;
        case AG_MSG._e:
        case AG_MSG.re:
          break;
        case AG_MSG.de:
          c = J(w(t.reqIndex.toString(16)));
          a = new Uint8Array(6 + (2 + n.length)),
            _.push(r),
            _.push(c),
            _.push(s),
            _.push(n);
          break;
        case AG_MSG.be:
          var V;
          c = J(w(t.reqIndex.toString(16))),
            I = J(W((V = q(R.agentId + "_" + t.groupId)).length.toString(16)));
          a = new Uint8Array(6 + (2 + n.length) + (2 + V.length)),
            _.push(r),
            _.push(c),
            _.push(s),
            _.push(n),
            _.push(I),
            _.push(V);
          break;
        case AG_MSG.ke:
          a = new Uint8Array(2),
            _.push(r);
          break;
        case AG_MSG.ge:
          a = new Uint8Array(4);
          var u = J(W(t.reqPageNum.toString(16)));
          _.push(r),
            _.push(u)
      }
      return Q(a, 0, _),
        a
    },
    e.constructSingleMsg = function (e, t, R, a, O, E) {
      var _ = E.agentId,
        r = E.userId,
        n = E.starUid,
        s = (E.starToken, J(W(AG_MSG.$.toString(16)))),
        c = q(n),
        S = J(W(c.length.toString(16))),
        i = q(_ + "_" + e),
        I = J(W(i.length.toString(16))),
        o = J(w(t.toString(16))),
        A = ENCRYPT_TYPE.m,
        N = MSG_DATA_TYPE.v;
      null != O && (N = O);
      var M = {
          fromId: r,
          targetId: e,
          time: (new Date).getTime(),
          msgIndex: t,
          type: 1,
          code: 0,
          contentData: a
        },
        V = L(R, JSON.stringify(M)),
        u = J(w(V.length.toString(16))),
        C = new Uint8Array(c.length + i.length + V.length + 16),
        T = [];
      return T.push(s),
        T.push(S),
        T.push(c),
        T.push(I),
        T.push(i),
        T.push(o),
        T.push([A]),
        T.push([N]),
        T.push(u),
        T.push(V),
        Q(C, 0, T),
        C
    },
    e.constructGroupMsg = function (e, t, R, a, O) {
      var E = O.agentId,
        _ = O.userId,
        r = O.starUid,
        n = (O.starToken, J(W(AG_MSG.ne.toString(16)))),
        s = q(""),
        c = J(W(s.length.toString(16))),
        S = J(w(t.toString(16))),
        i = q(E + "_" + e),
        I = J(W(i.length.toString(16))),
        o = q(r),
        A = J(W(o.length.toString(16))),
        N = ENCRYPT_TYPE.m,
        M = MSG_DATA_TYPE.v,
        V = {
          fromId: _,
          targetId: e,
          time: (new Date).getTime(),
          msgIndex: t,
          type: 1,
          code: 0,
          contentData: a
        },
        u = L(R, JSON.stringify(V)),
        C = J(w(u.length.toString(16))),
        T = new Uint8Array(s.length + i.length + o.length + u.length + 18),
        P = [];
      return P.push(n),
        P.push(c),
        P.push(s),
        P.push(S),
        P.push(I),
        P.push(i),
        P.push(A),
        P.push(o),
        P.push([N]),
        P.push([M]),
        P.push(C),
        P.push(u),
        Q(T, 0, P),
        T
    },
    e.constructReceivedMsg = function (e, t) {
      t.agentId,
        t.userId;
      var R = t.starUid,
        a = (t.starToken, J(W(AG_MSG.Ce.toString(16)))),
        O = q(R),
        E = J(W(O.length.toString(16))),
        _ = J(w(e.msgIndex.toString(16))),
        r = new Uint8Array(e.msgNode),
        n = new Uint8Array(O.length + 16),
        s = [];
      return s.push(a),
        s.push(E),
        s.push(O),
        s.push(_),
        s.push(r),
        Q(n, 0, s),
        n
    },
    e.constructSingleCtrlMsg = function (e, t, R, a, O, E) {
      var _ = E.agentId,
        r = E.userId,
        n = E.starUid,
        s = (E.starToken, J(W(AG_MSG.$.toString(16)))),
        c = q(n),
        S = J(W(c.length.toString(16))),
        i = q(_ + "_" + e),
        I = J(W(i.length.toString(16))),
        o = J(w(t.toString(16))),
        A = ENCRYPT_TYPE.m,
        N = MSG_DATA_TYPE.U,
        M = {
          fromId: r,
          targetId: e,
          time: (new Date).getTime(),
          msgIndex: t,
          type: 0,
          code: parseInt(O),
          contentData: a
        },
        V = L(R, JSON.stringify(M)),
        u = J(w(V.length.toString(16))),
        C = new Uint8Array(c.length + i.length + V.length + 16),
        T = [];
      return T.push(s),
        T.push(S),
        T.push(c),
        T.push(I),
        T.push(i),
        T.push(o),
        T.push([A]),
        T.push([N]),
        T.push(u),
        T.push(V),
        Q(C, 0, T),
        C
    },
    e.constructVOIPProtocol = function (e, t, R) {
      var a, O = R.agentId,
        E = (R.userId, R.starUid),
        _ = R.starToken,
        r = [],
        n = J(W(e.toString(16))),
        s = q(E),
        c = J(W(s.length.toString(16))),
        S = q(_),
        i = J(W(S.length.toString(16)));
      switch (e) {
        case AG_VOIPMOONSERVER.gt:
        case AG_VOIPMOONSERVER.yt:
          var I = q(O + "_" + t.targetId),
            o = J(W(I.length.toString(16))),
            A = J(B(8, parseInt(t.audioSSRC).toString(16))),
            N = J(B(8, parseInt(t.videoSSRC).toString(16))),
            M = J(B(2, parseInt(t.videoCodec).toString(16))),
            V = J(B(2, parseInt(t.audioCodec).toString(16)));
          a = new Uint8Array(2 + (2 + s.length) + (2 + S.length) + (2 + I.length) + 4 + 4 + 1 + 1),
            r.push(n),
            r.push(c),
            r.push(s),
            r.push(i),
            r.push(S),
            r.push(o),
            r.push(I),
            r.push(A),
            r.push(N),
            r.push(M),
            r.push(V);
          break;
        case AG_VOIPMOONSERVER.Yt:
          var u = t.isActive;
          a = new Uint8Array(3),
            r.push(n),
            r.push([u])
      }
      return Q(a, 0, r),
        a
    },
    e.constructSrcProtocol = function (e, t, R) {
      R.agentId;
      var a = R.userId,
        O = R.starUid,
        E = R.starToken,
        _ = [],
        r = J(W(e.toString(16))),
        n = J(W((M = q(O)).length.toString(16))),
        s = J(W((v = q(E)).length.toString(16)));
      switch (e) {
        case AG_LIVESRCMOONSERVER.Fa:
        case AG_LIVESRCMOONSERVER.mR:
        case AG_LIVESRCMOONSERVER.gR:
          var c = J(W(t.conCurrentNum.toString(16))),
            S = J(W((0).toString(16))),
            i = J(W((A = q(t.roomId)).length.toString(16))),
            I = t.liveType,
            o = J(W((C = q(t.extra)).length.toString(16)));
          Y = new Uint8Array(2 + (2 + M.length) + (2 + v.length) + 2 + 2 + (2 + A.length) + 1 + (2 + C.length)),
            _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(c),
            _.push(S),
            _.push(i),
            _.push(A),
            _.push([I]),
            _.push(o),
            _.push(C);
          break;
        case AG_LIVESRCMOONSERVER.wR:
          c = J(W(t.conCurrentNum.toString(16))),
            S = J(W(t.validTime.toString(16))),
            i = J(W((A = q(t.roomId)).length.toString(16))),
            o = J(W((C = q(t.extra)).length.toString(16)));
          var A, N = J(W((T = q(t.spec)).length.toString(16)));
          _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(c),
            _.push(S),
            _.push(i),
            _.push(A),
            _.push(o),
            _.push(C),
            _.push(N),
            _.push(T);
          break;
        case AG_LIVESRCMOONSERVER.yR:
          n = J(W((M = q(a)).length.toString(16))),
            s = J(W((v = q(E)).length.toString(16))),
            S = J(W((0).toString(16)));
          var M, V = J(W((u = q(t.groupId)).length.toString(16)));
          o = J(W((C = q(t.extra)).length.toString(16)));
          _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(S),
            _.push(V),
            _.push(u),
            _.push(o),
            _.push(C);
          break;
        case AG_LIVESRCMOONSERVER.hR:
          var u, C, T;
          S = J(W((0).toString(16))),
            V = J(W((u = q(t.groupId)).length.toString(16))),
            o = J(W((C = q(t.extra)).length.toString(16))),
            N = J(W((T = q(t.spec)).length.toString(16)));
          _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(S),
            _.push(V),
            _.push(u),
            _.push(o),
            _.push(C),
            _.push(N),
            _.push(T);
          break;
        case AG_LIVESRCMOONSERVER.xR:
          var P = q(t.channelId),
            L = q(t.avParam),
            G = J(W(L.length.toString(16)));
          _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(P),
            _.push(G),
            _.push(L);
          break;
        case AG_LIVESRCMOONSERVER.FR:
          P = q(t.channelId);
          var l = J(W((f = q(t.upUserId)).length.toString(16)));
          _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(P),
            _.push(l),
            _.push(f);
          break;
        case AG_LIVESRCMOONSERVER.KR:
        case AG_LIVESRCMOONSERVER.WR:
        case AG_LIVESRCMOONSERVER.BR:
          var f;
          P = q(t.channelId),
            l = J(W((f = q(t.upUserId)).length.toString(16)));
          _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(P),
            _.push(l),
            _.push(f);
          break;
        case AG_LIVESRCMOONSERVER.qR:
        case AG_LIVESRCMOONSERVER.JR:
          P = q(t.channelId);
          Y = new Uint8Array(2 + (2 + M.length) + (2 + v.length) + 16),
            _.push(r),
            _.push(n),
            _.push(M),
            _.push(s),
            _.push(v),
            _.push(P);
          break;
        case AG_LIVESRCMOONSERVER.QR:
          for (var D = t.streamConfig,
              p = new Uint8Array(16), U = 0; U < 16; U++) null != D[U] ? p[U] = D[U] : p[U] = 0;
          Y = new Uint8Array(18),
            _.push(r),
            _.push(p);
          break;
        case AG_LIVESRCMOONSERVER.jR:
          P = q(t.channelId);
          _.push(r),
            _.push(P);
          break;
        case AG_LIVESRCMOONSERVER.zR:
          _.push(r);
          break;
        case AG_LIVESRCMOONSERVER.XR:
          var d = q(t.streamData);
          Y = new Uint8Array(3 + d.length),
            _.push(r),
            _.push([t.streamDataType]),
            _.push(d);
          break;
        case AG_LIVESRCMOONSERVER.YR:
          var v, b = q(O),
            H = J(W(b.length.toString(16))),
            k = (s = J(W((v = q(E)).length.toString(16))), P = q(t.channelId), J(B(8, parseInt(t.audioSSRC).toString(16)))),
            m = J(B(8, parseInt(t.smallVideoSSRC).toString(16))),
            g = J(B(8, parseInt(t.bigVideoSSRC).toString(16))),
            w = J(B(2, parseInt(t.videoCodec).toString(16))),
            y = J(B(2, parseInt(t.audioCodec).toString(16))),
            h = J(W((F = q(t.iceUfrag)).length.toString(16))),
            x = J(W((K = q(t.icePwd)).length.toString(16))),
            Y = new Uint8Array(b.length + v.length + 34 + 1 + 1 + 2 + F.length + 2 + K.length);
          _.push(r),
            _.push(H),
            _.push(b),
            _.push(s),
            _.push(v),
            _.push(P),
            _.push(k),
            _.push(m),
            _.push(g),
            _.push(w),
            _.push(y),
            _.push(F),
            _.push(K);
          break;
        case AG_LIVESRCMOONSERVER.ha:
          var F, K;
          h = J(W((F = q(t.iceUfrag)).length.toString(16))),
            x = J(W((K = q(t.icePwd)).length.toString(16)));
          Y = new Uint8Array(4 + F.length + 2 + K.length),
            _.push(r),
            _.push(h),
            _.push(F),
            _.push(x),
            _.push(K)
      }
      return Q(Y, 0, _),
        Y
    },
    e.constructVdnProtocol = function (e, t, R) {
      R.agentId,
        R.userId;
      var a, O = R.starUid,
        E = R.starToken,
        _ = [],
        r = J(W(e.toString(16))),
        n = q(O),
        s = J(W(n.length.toString(16))),
        c = q(E),
        S = J(W(c.length.toString(16)));
      switch (e) {
        case AG_LIVEVDNMOONSERVER.Ba:
          var i = q(t.iceUfrag),
            I = J(W(i.length.toString(16))),
            o = q(t.icePwd),
            A = J(W(o.length.toString(16)));
          a = new Uint8Array(4 + i.length + 2 + o.length),
            _.push(r),
            _.push(I),
            _.push(i),
            _.push(A),
            _.push(o);
          break;
        case AG_LIVEVDNMOONSERVER.qa:
          var N = q(t.channelId);
          a = new Uint8Array(18 + (2 + n.length) + (2 + c.length)),
            _.push(r),
            _.push(N),
            _.push(s),
            _.push(n),
            _.push(S),
            _.push(c);
          break;
        case AG_LIVEVDNMOONSERVER.Ja:
        case AG_LIVEVDNMOONSERVER.Qa:
          a = new Uint8Array(2),
            _.push(r);
          break;
        case AG_LIVEVDNMOONSERVER.za:
        case AG_LIVEVDNMOONSERVER.ja:
          N = q(t.channelId);
          a = new Uint8Array(18),
            _.push(r),
            _.push(N);
          break;
        case AG_LIVEVDNMOONSERVER.Xa:
          for (var M = t.streamConfig,
              V = new Uint8Array(16), u = 0; u < 16; u++) null != M[u] ? V[u] = M[u] : V[u] = 0;
          a = new Uint8Array(18),
            _.push(r),
            _.push(V)
      }
      return Q(a, 0, _),
        a
    },
    e.constructChatProtocol = function (e, t, R) {
      var a, O = R.agentId,
        E = R.userId,
        _ = R.starUid,
        r = R.starToken,
        n = [],
        s = J(W(e.toString(16))),
        c = q(_),
        S = J(W(c.length.toString(16))),
        i = q(r),
        I = J(W(i.length.toString(16)));
      if (e == AG_CHATROOMMOONSERVER.Ye) {
        var o = t.roomType,
          A = J(W(t.conCurrentNum.toString(16))),
          N = J(w((d = q(t.userDefineData)).length.toString(16)));
        a = new Uint8Array(2 + (2 + c.length) + (2 + i.length) + 1 + 2 + (4 + d.length)),
          n.push(s),
          n.push(S),
          n.push(c),
          n.push(I),
          n.push(i),
          n.push([o]),
          n.push(A),
          n.push(N),
          n.push(d)
      } else if (e == AG_CHATROOMMOONSERVER.Fe) a = new Uint8Array(2),
        n.push(s);
      else if (e == AG_CHATROOMMOONSERVER.Ke) {
        var M = q(O + "_" + t.banUserId),
          V = J(W(M.length.toString(16))),
          u = J(W(t.banTime.toString(16)));
        a = new Uint8Array(2 + (2 + M.length) + 2),
          n.push(s),
          n.push(V),
          n.push(M),
          n.push(u)
      } else if (e == AG_CHATROOMMOONSERVER.We) {
        var C = q(O + "_" + t.kickOutUserId),
          T = J(W(C.length.toString(16)));
        a = new Uint8Array(2 + (2 + C.length)),
          n.push(s),
          n.push(T),
          n.push(C)
      } else if (e == AG_CHATROOMMOONSERVER.Be) a = new Uint8Array(2),
        n.push(s);
      else if (e == AG_CHATROOMMOONSERVER.qe) {
        var P = q(t.roomId);
        a = new Uint8Array(2 + (2 + c.length) + (2 + i.length) + 16),
          n.push(s),
          n.push(S),
          n.push(c),
          n.push(I),
          n.push(i),
          n.push(P)
      } else if (e == AG_CHATROOMMOONSERVER.Je);
      else if (e == AG_CHATROOMMOONSERVER.Qe) a = new Uint8Array(2),
        n.push(s);
      else if (e == AG_CHATROOMMOONSERVER.je) {
        var L = {
            fromId: E,
            targetId: t.roomId,
            time: (new Date).getTime(),
            msgIndex: t.msgIndex,
            type: 1,
            code: 0,
            contentData: t.msg
          },
          G = q(JSON.stringify(L)),
          l = J(w(G.length.toString(16)));
        a = new Uint8Array(2 + (4 + G.length)),
          n.push(s),
          n.push(l),
          n.push(G)
      } else if (e == AG_CHATROOMMOONSERVER.Xe) {
        L = {
          fromId: E,
          targetId: t.roomId,
          time: (new Date).getTime(),
          msgIndex: t.msgIndex,
          type: parseInt(t.type),
          code: parseInt(t.code),
          contentData: t.msg
        };
        var f = q(JSON.stringify(L)),
          D = J(w(f.length.toString(16))),
          p = q(O + "_" + t.toUserId),
          U = J(W(p.length.toString(16)));
        a = new Uint8Array(2 + (2 + p.length) + (4 + f.length)),
          n.push(s),
          n.push(U),
          n.push(p),
          n.push(D),
          n.push(f)
      } else if (e == AG_CHATROOMMOONSERVER.ze) {
        P = q(t.roomId);
        a = new Uint8Array(18),
          n.push(s),
          n.push(P)
      } else if (e == AG_CHATROOMMOONSERVER.Gt) {
        var d, v = J(W((H = q(E)).length.toString(16))),
          b = J(W(t.listType.toString(16)));
        N = J(w((d = q(t.userDefineData)).length.toString(16))),
          P = q(t.roomId);
        a = new Uint8Array(4 + (2 + H.length) + 16 + (4 + d.length)),
          n.push(s),
          n.push(b),
          n.push(v),
          n.push(H),
          n.push(P),
          n.push(N),
          n.push(d)
      } else if (e == AG_CHATROOMMOONSERVER.Dt) {
        b = J(W(t.listType.toString(16))),
          P = q(t.roomId),
          v = J(W((H = q(E)).length.toString(16)));
        a = new Uint8Array(4 + (2 + H.length) + 16),
          n.push(s),
          n.push(b),
          n.push(v),
          n.push(H),
          n.push(P)
      } else if (e == AG_CHATROOMMOONSERVER.dt) {
        var H, k = q(t.listTypes),
          m = J(W(k.length.toString(16))),
          g = J(W((H = q(t.userId)).length.toString(16)));
        a = new Uint8Array(2 + (2 + k.length) + (2 + H.length)),
          n.push(s),
          n.push(m),
          n.push(k),
          n.push(g),
          n.push(H)
      }
      return Q(a, 0, n),
        a
    },
    e.parseMessage = function (e, t) {
      var R = new Uint8Array(e);
      switch (parseInt("0x" + g(R.slice(0, 2)))) {
        case AG_MSG.J:
          R = new Uint8Array(e);
          var a = parseInt("0x" + g(R.slice(2, 4)));
          StarRtc.info("", a),
            t({
                status: "success",
                msgMaxLen: a
              },
              "onLoginMessage");
          break;
        case AG_MSG.j:
          StarRtc.warn(""),
            t({
                status: "failed"
              },
              "onLoginMessage");
          break;
        case AG_MSG.Z:
          StarRtc.debug("");
          break;
        case AG_MSG.Ve:
          StarRtc.debug("");
          break;
        case AG_MSG.ue:
          StarRtc.info("");
          parseInt("0x" + g(R.slice(14, 18)));
          var O = parseInt("0x" + g(R.slice(2, 6))),
            E = R.slice(6, 14),
            _ = 19;
          switch (R[18]) {
            case MSG_TYPE.L:
              StarRtc.info("");
              var r = parseInt("0x" + g(R.slice(_, _ + 2)));
              _ += 2;
              var n = m(R.slice(_, _ + r)),
                s = R[_ += r];
              switch (_ += 1, s) {
                case ENCRYPT_TYPE.m:
                  var c = parseInt("0x" + g(R.slice(_, _ + 4)));
                  _ += 4;
                  var S = k(R.slice(_, _ + c));
                  StarRtc.debug(n, S.digest, S.content),
                    2 == (o = n.split("_")).length && (n = o[1]),
                    t(e = {
                        fromId: n,
                        digest: S.digest,
                        msg: S.content,
                        msgIndex: O,
                        msgNode: E
                      },
                      "onSingleMessage");
                  break;
                case ENCRYPT_TYPE.g:
              }
              break;
            case MSG_TYPE.G:
              StarRtc.info("");
              var i = parseInt("0x" + g(R.slice(_, _ + 2)));
              _ += 2;
              var I = m(R.slice(_, _ + i));
              _ += i;
              r = parseInt("0x" + g(R.slice(_, _ + 2)));
              _ += 2;
              n = m(R.slice(_, _ + r)),
                s = R[_ += r];
              switch (_ += 1, s) {
                case ENCRYPT_TYPE.m:
                  c = parseInt("0x" + g(R.slice(_, _ + 4)));
                  _ += 4;
                  S = k(R.slice(_, _ + c));
                  StarRtc.debug(I, n, S.digest, S.content),
                    2 == (o = n.split("_")).length && (n = o[1]),
                    2 == (A = I.split("_")).length && (I = A[1]),
                    t(e = {
                        groupId: I,
                        fromId: n,
                        digest: S.digest,
                        msg: S.content,
                        msgIndex: O,
                        msgNode: E
                      },
                      "onGroupMessage");
                  break;
                case ENCRYPT_TYPE.g:
              }
              break;
            case MSG_TYPE.l:
              StarRtc.info("");
              i = parseInt("0x" + g(R.slice(_, _ + 2)));
              _ += 2;
              I = m(R.slice(_, _ + i));
              _ += i;
              r = parseInt("0x" + g(R.slice(_, _ + 2)));
              _ += 2;
              n = m(R.slice(_, _ + r)),
                s = R[_ += r];
              switch (_ += 1, s) {
                case ENCRYPT_TYPE.m:
                  c = parseInt("0x" + g(R.slice(_, _ + 4)));
                  _ += 4;
                  var o;
                  S = k(R.slice(_, _ + c));
                  StarRtc.debug(I, n, S.digest, S.content),
                    2 == (o = n.split("_")).length && (n = o[1]),
                    2 == (A = I.split("_")).length && (I = A[1]),
                    t(e = {
                        groupId: I,
                        fromId: n,
                        digest: S.digest,
                        msg: S.content,
                        msgIndex: O,
                        msgNode: E
                      },
                      "onGroupPrivateMessage");
                  break;
                case ENCRYPT_TYPE.g:
              }
              break;
            case MSG_TYPE.D:
              StarRtc.info("");
              i = parseInt("0x" + g(R.slice(_, _ + 2)));
              _ += 2;
              I = m(R.slice(_, _ + i));
              _ += i;
              c = parseInt("0x" + g(R.slice(_, _ + 4)));
              _ += 4;
              var A;
              S = k(R.slice(_, _ + c));
              StarRtc.debug(I, S.digest, S.content),
                2 == (A = I.split("_")).length && (I = A[1]),
                t(e = {
                    groupId: I,
                    digest: S.digest,
                    msg: S.content,
                    msgIndex: O,
                    msgNode: E
                  },
                  "onGroupPushMessage");
              break;
            case MSG_TYPE.p:
              StarRtc.info("");
              c = parseInt("0x" + g(R.slice(_, _ + 4)));
              _ += 4;
              S = k(R.slice(_, _ + c));
              StarRtc.debug(S.digest, S.content),
                t(e = {
                    digest: S.digest,
                    msg: S.content,
                    msgIndex: O,
                    msgNode: E
                  },
                  "onSystemPushMessage")
          }
          break;
        case AG_MSG.Te:
          var N = parseInt("0x" + g(R.slice(2, 4))),
            M = m(R.slice(6, R.byteLength));
          StarRtc.error(":", N, M),
            t(e = {
                errId: N,
                errStr: M
              },
              "onErrorMessage");
          break;
        case AG_MSG.se:
          var V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            C = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4)));
          i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              groupMsgIndex: C,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i)),
              serverTimestamp: parseInt("0x" + g(R.slice(4 + V + 4 + 2 + i, 4 + V + 4 + 2 + i + 4)))
            },
            "onSendGroupMsgFin");
          break;
        case AG_MSG.ce:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V));
          var T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4)));
          i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onCreateGroupFin");
          break;
        case AG_MSG.Se:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4))),
            i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onDelGroupFin");
          break;
        case AG_MSG.ie:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4))),
            i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onAddGroupUserFin");
          break;
        case AG_MSG.Ie:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4))),
            i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onRemoveGroupUserFin");
          break;
        case AG_MSG.oe:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4))),
            i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onSetGroupMsgIgnoreFin");
          break;
        case AG_MSG.Ae:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4))),
            i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onUnsetGroupMsgIgnoreFin");
          break;
        case AG_MSG.Ne:
          V = parseInt("0x" + g(R.slice(2, 4)));
          t({
              status: "success",
              statusStr: u = m(R.slice(4, 4 + V)),
              reqIndex: T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4)))
            },
            "onPushSystemMsgFin");
          break;
        case AG_MSG.Me:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4))),
            i = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 2)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupId: I = m(R.slice(4 + V + 4 + 2, 4 + V + 4 + 2 + i))
            },
            "onPushGroupSystemMsgFin");
          break;
        case AG_MSG.ve:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4)));
          var P = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 4))),
            L = m(R.slice(4 + V + 4 + 4, 4 + V + 4 + 4 + P)).split(",");
          0 == P && (L = []);
          for (var G = parseInt("0x" + g(R.slice(4 + V + 4 + 4 + P, 4 + V + 4 + 4 + P + 4))), l = m(R.slice(4 + V + 4 + 4 + P + 4, 4 + V + 4 + 4 + P + 4 + G)).split(","), f = parseInt("0x" + g(R.slice(4 + V + 4 + 4 + P + 4 + G, 4 + V + 4 + 4 + P + 4 + G + 4))), D = m(R.slice(4 + V + 4 + 4 + P + 4 + G + 4, 4 + V + 4 + 4 + P + 4 + G + 4 + f)).split(","), p = [], U = 0; U < L.length; U++) {
            var d = {
              groupId: L[U],
              groupName: l[U],
              creator: D[U]
            };
            p.push(d)
          }
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              groupsInfo: p
            },
            "onGetGroupList");
          break;
        case AG_MSG.He:
          V = parseInt("0x" + g(R.slice(2, 4))),
            u = m(R.slice(4, 4 + V)),
            T = parseInt("0x" + g(R.slice(4 + V, 4 + V + 4)));
          var v = parseInt("0x" + g(R.slice(4 + V + 4, 4 + V + 4 + 4)));
          t({
              status: "success",
              statusStr: u,
              reqIndex: T,
              userIdList: m(R.slice(4 + V + 4 + 4, 4 + V + 4 + 4 + v)).split(",")
            },
            "onGetGroupUserList");
          break;
        case AG_MSG.me:
          t({
              status: "success",
              count: parseInt("0x" + g(R.slice(2, 6))),
              totalPageNum: b = parseInt("0x" + g(R.slice(6, 8)))
            },
            "onGetOnlineNumber");
          break;
        case AG_MSG.we:
          var b = parseInt("0x" + g(R.slice(2, 4))),
            H = parseInt("0x" + g(R.slice(4, 6)));
          v = parseInt("0x" + g(R.slice(6, 10)));
          t({
              status: "success",
              totalPageNum: b,
              reqPageNum: H,
              userIdList: m(R.slice(10, 10 + v)).split(",")
            },
            "onGetAllUserList");
          break;
        case AG_MSG.ye:
          t({
              status: "failed",
              totalPageNum: b = parseInt("0x" + g(R.slice(2, 4))),
              reqPageNum: H = parseInt("0x" + g(R.slice(4, 6)))
            },
            "onGetAllUserList")
      }
    },
    e.parseSrcMoonServerMessage = function (e, t) {
      var R = new Uint8Array(e);
      switch (parseInt("0x" + g(R.slice(0, 2)))) {
        case AG_LIVESRCMOONSERVER.ta:
          var a = parseInt("0x" + g(R.slice(18, 20)));
          t({
            type: "srcApplyUpload",
            status: "success",
            fingerprint: m(R.slice(20, 20 + a)),
            recSessionId: parseInt("0x" + g(R.slice(20 + a, 20 + a + 8)))
          });
          break;
        case AG_LIVESRCMOONSERVER.Ra:
          var O = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "srcApplyUpload",
            status: "failed",
            msg: i = m(R.slice(4, 4 + O))
          });
          break;
        case AG_LIVESRCMOONSERVER.Pa:
          StarRtc.debug("webrtc");
          break;
        case AG_LIVESRCMOONSERVER.La:
          for (var E = parseInt("0x" + g(R.slice(2, 3))), _ = 3, r = R.length, n = {
              siv: E,
              uperInfos: {}
            }; _ < r;) {
            var s = parseInt("0x" + g(R.slice(_, _ + 1)));
            _ += 1;
            var c = parseInt("0x" + g(R.slice(_, _ + 2)));
            _ += 2;
            var S = m(R.slice(_, _ + c));
            _ += c,
              n.uperInfos[s] = {
                upId: s,
                userId: S
              }
          }
          t({
            type: "uperStreamInfoUpdate",
            status: "success",
            msg: n
          });
          break;
        case AG_LIVESRCMOONSERVER.Ta:
          t({
            type: "stopStream",
            status: "success"
          });
          break;
        case AG_LIVESRCMOONSERVER.Na:
          t({
            type: "streamConfig",
            status: "success",
            channelId: m(R.slice(2, 18))
          });
          break;
        case AG_LIVESRCMOONSERVER.Ma:
          t({
            type: "streamConfig",
            status: "failed",
            channelId: m(R.slice(2, 18))
          });
          break;
        case AG_LIVESRCMOONSERVER.oa:
          t({
            type: "delChannel",
            status: "success",
            channelId: m(R.slice(2, 18))
          });
          break;
        case AG_LIVESRCMOONSERVER.Aa:
          O = parseInt("0x" + g(R.slice(2, 4)));
          var i = m(R.slice(4, 4 + O));
          t({
            type: "delChannel",
            status: "failed",
            channelId: m(R.slice(4 + O, 4 + O + 16)),
            msg: i
          });
          break;
        case AG_LIVESRCMOONSERVER.ZR:
          t({
            type: "createChannel",
            status: "success",
            channelId: m(R.slice(2, 18))
          });
          break;
        case AG_LIVESRCMOONSERVER.$R:
          O = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "createChannel",
            status: "failed",
            msg: i = m(R.slice(4, 4 + O))
          });
          break;
        case AG_LIVESRCMOONSERVER.Ga:
          s = parseInt("0x" + g(R.slice(2, 3))),
            E = parseInt("0x" + g(R.slice(3, 4)));
          var I = m(R.slice(5));
          t({
            type: "streamData",
            status: "success",
            upId: s,
            siv: E,
            streamDataType: parseInt("0x" + g(R.slice(4, 5))),
            streamData: I
          });
          break;
        case AG_LIVESRCMOONSERVER.la:
          (i = {}).errId = parseInt("0x" + g(R.slice(2, 4))),
            i.errStrlen = parseInt("0x" + g(R.slice(4, 6))),
            i.errStr = m(R.slice(6, 6 + i.errStrlen)),
            t({
              type: "serverErr",
              status: "failed",
              msg: i
            });
          break;
        case AG_LIVESRCMOONSERVER.xa:
          a = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "webrtcReg",
            status: "success",
            fingerprint: m(R.slice(4, 4 + a))
          });
          break;
        case AG_LIVESRCMOONSERVER.Ya:
          t({
            type: "webrtcConnect",
            status: "success"
          })
      }
    },
    e.parseVdnMoonServerMessage = function (e, t) {
      var R = new Uint8Array(e);
      switch (parseInt("0x" + g(R.slice(0, 2)))) {
        case AG_LIVEVDNMOONSERVER.Za:
          var a = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "webrtcReg",
            status: "success",
            fingerprint: m(R.slice(4, 4 + a))
          });
          break;
        case AG_LIVEVDNMOONSERVER.$a:
          for (var O = m(R.slice(2, 18)), E = parseInt("0x" + g(R.slice(18, 19))), _ = 19, r = R.length, n = {
              siv: E,
              uperInfos: {}
            }; _ < r;) {
            var s = parseInt("0x" + g(R.slice(_, _ + 1)));
            _ += 1;
            var c = parseInt("0x" + g(R.slice(_, _ + 2)));
            _ += 2;
            var S = m(R.slice(_, _ + c));
            _ += c,
              n.uperInfos[s] = {
                upId: s,
                userId: S
              }
          }
          t({
            type: "vdnApplyDownload",
            status: "success",
            channelId: O,
            uperInfos: n
          });
          break;
        case AG_LIVEVDNMOONSERVER.eO:
          StarRtc.debug("vdn ");
          break;
        case AG_LIVEVDNMOONSERVER.tO:
          var i = parseInt("0x" + g(R.slice(2, 4))),
            I = m(R.slice(4, 4 + i));
          t({
            type: "vdnApplyDownload",
            status: "failed",
            channelId: O = m(R.slice(4 + i, 4 + i + 16)),
            failedStatus: I
          });
          break;
        case AG_LIVEVDNMOONSERVER.RO:
          t({
            type: "streamConfig",
            status: "success",
            channelId: O = m(R.slice(2, 18))
          });
          break;
        case AG_LIVEVDNMOONSERVER.aO:
          t({
            type: "streamConfig",
            status: "failed",
            channelId: O = m(R.slice(2, 18))
          });
          break;
        case AG_LIVEVDNMOONSERVER.OO:
          for (O = m(R.slice(2, 18)), E = parseInt("0x" + g(R.slice(18, 19))), _ = 19, r = R.length, n = {
              channelId: O,
              siv: E,
              uperInfos: {}
            }; _ < r;) {
            s = parseInt("0x" + g(R.slice(_, _ + 1)));
            _ += 1;
            c = parseInt("0x" + g(R.slice(_, _ + 2)));
            _ += 2;
            S = m(R.slice(_, _ + c));
            _ += c,
              n.uperInfos[s] = {
                upId: s,
                userId: S
              }
          }
          t({
            type: "uperStreamInfoUpdate",
            status: "success",
            channelId: O,
            msg: n
          });
          break;
        case AG_LIVEVDNMOONSERVER.EO:
          t({
            type: "streamData",
            status: "success",
            upId: s = parseInt("0x" + g(R.slice(2, 3))),
            siv: E = parseInt("0x" + g(R.slice(3, 4))),
            streamDataType: parseInt("0x" + g(R.slice(4, 5))),
            streamData: m(R.slice(5))
          });
          break;
        case AG_LIVEVDNMOONSERVER._O:
          break;
        case AG_LIVEVDNMOONSERVER.iO:
          t({
            type: "webrtcConnect",
            status: "success"
          });
          break;
        case AG_LIVEVDNMOONSERVER.rO:
        case AG_LIVEVDNMOONSERVER.nO:
          break;
        case AG_LIVEVDNMOONSERVER.cO:
          var o = {};
          o.errId = parseInt("0x" + g(R.slice(2, 4))),
            o.errStrlen = parseInt("0x" + g(R.slice(4, 6))),
            o.errStr = m(R.slice(6, 6 + o.errStrlen)),
            t({
              type: "serverErr",
              status: "failed",
              msg: o
            })
      }
    },
    e.parseChatMoonServerMessage = function (e, t) {
      var R = new Uint8Array(e),
        a = parseInt("0x" + g(R.slice(0, 2)));
      switch (a) {
        case AG_CHATROOMMOONSERVER.Ze:
          t({
            type: "createChatRoom",
            status: "success",
            chatroomId: E = m(R.slice(2, 18)),
            maxContentLen: parseInt("0x" + g(R.slice(18, 20)))
          });
          break;
        case AG_CHATROOMMOONSERVER.$e:
          var O = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "createChatRoom",
            status: "failed",
            status: m(R.slice(4, 4 + O))
          });
          break;
        case AG_CHATROOMMOONSERVER.et:
          t({
            type: "deleteChatRoom",
            status: "success",
            roomId: E = m(R.slice(2, 18))
          });
          break;
        case AG_CHATROOMMOONSERVER.tt:
          var E = m(R.slice(2, 18));
          O = parseInt("0x" + g(R.slice(18, 20)));
          t({
            type: "deleteChatRoom",
            status: "failed",
            msg: m(R.slice(20, 20 + O)),
            roomId: E
          });
          break;
        case AG_CHATROOMMOONSERVER.Rt:
          var _ = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "banaedToSendMsg",
            status: "success",
            banUserId: r = m(R.slice(4, 4 + _)),
            banTime: n = parseInt("0x" + g(R.slice(4 + _, 4 + _ + 2)))
          });
          break;
        case AG_CHATROOMMOONSERVER.at:
          _ = parseInt("0x" + g(R.slice(2, 4)));
          var r = m(R.slice(4, 4 + _)),
            n = parseInt("0x" + g(R.slice(4 + _, 4 + _ + 2)));
          O = parseInt("0x" + g(R.slice(4 + _ + 2, 4 + _ + 2 + 2)));
          t({
            type: "banaedToSendMsg",
            status: "failed",
            banUserId: r,
            banTime: n,
            msg: m(R.slice(4 + _ + 2 + 2, 4 + _ + 2 + 2 + O))
          });
          break;
        case AG_CHATROOMMOONSERVER.Ot:
          var s = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "kickOutUser",
            status: "success",
            kickOutUserId: c = m(R.slice(4, 4 + s))
          });
          break;
        case AG_CHATROOMMOONSERVER.Et:
          s = parseInt("0x" + g(R.slice(2, 4)));
          var c = m(R.slice(4, 4 + s));
          O = parseInt("0x" + g(R.slice(4 + s, 4 + _ + 2)));
          t({
            type: "kickOutUser",
            status: "failed",
            kickOutUserId: c,
            msg: m(R.slice(4 + s + 2, 4 + s + 2 + O))
          });
          break;
        case AG_CHATROOMMOONSERVER._t:
        case AG_CHATROOMMOONSERVER.rt:
          t({
            type: "joinChatRoom",
            status: "success",
            roomId: E = m(R.slice(2, 18)),
            maxContentLen: parseInt("0x" + g(R.slice(18, 20)))
          });
          break;
        case AG_CHATROOMMOONSERVER.nt:
          E = m(R.slice(2, 18)),
            O = parseInt("0x" + g(R.slice(18, 20)));
          t({
            type: "joinChatRoom",
            status: "failed",
            failedStatus: m(R.slice(20, 20 + O)),
            roomId: E
          });
          break;
        case AG_CHATROOMMOONSERVER.st:
          StarRtc.debug("chatRoom");
          break;
        case AG_CHATROOMMOONSERVER.ct:
        case AG_CHATROOMMOONSERVER.St:
          var S = parseInt("0x" + g(R.slice(2, 4))),
            i = m(R.slice(4, 4 + S)),
            I = parseInt("0x" + g(R.slice(4 + S, 4 + S + 4))),
            o = m(R.slice(4 + S + 4, 4 + S + 4 + I));
          t({
            type: a == AG_CHATROOMMOONSERVER.ct ? "recvChatPrivateMsg" : "recvChatMsg",
            status: "success",
            fromUserId: i,
            msg: o
          });
          break;
        case AG_CHATROOMMOONSERVER.it:
          t({
            type: "chatroomUserBannedMsg",
            status: "success",
            banTime: n = parseInt("0x" + g(R.slice(2, 4)))
          });
          break;
        case AG_CHATROOMMOONSERVER.It:
          t({
            type: "chatroomUserKicked",
            status: "success"
          });
          break;
        case AG_CHATROOMMOONSERVER.ot:
          t({
            type: "sendMsgNoFree"
          });
          break;
        case AG_CHATROOMMOONSERVER.At:
          (o = {}).errId = parseInt("0x" + g(R.slice(2, 4))),
            o.errStrlen = parseInt("0x" + g(R.slice(4, 6))),
            o.errStr = m(R.slice(6, 6 + o.errStrlen)),
            t({
              type: "serverErr",
              status: "failed",
              msg: o
            });
          break;
        case AG_CHATROOMMOONSERVER.Nt:
          t({
            type: "getRoomOnlineNum",
            status: "success",
            roomId: E = m(R.slice(2, 18)),
            onlineNum: parseInt("0x" + g(R.slice(18, 22)))
          });
          break;
        case AG_CHATROOMMOONSERVER.lt:
          t({
            type: "saveToChatroomList",
            status: "success",
            roomId: E = m(R.slice(2, 18))
          });
          break;
        case AG_CHATROOMMOONSERVER.ft:
          t({
            type: "saveToChatroomList",
            status: "failed",
            roomId: E = m(R.slice(2, 18))
          });
          break;
        case AG_CHATROOMMOONSERVER.pt:
          t({
            type: "delFromToChatroomList",
            status: "success",
            roomId: E = m(R.slice(2, 18))
          });
          break;
        case AG_CHATROOMMOONSERVER.Ut:
          t({
            type: "delFromToChatroomList",
            status: "failed",
            roomId: E = m(R.slice(2, 18))
          });
          break;
        case AG_CHATROOMMOONSERVER.vt:
          var A = parseInt("0x" + g(R.slice(2, 6)));
          t({
            type: "queryAllChatroomList",
            status: "success",
            listData: m(R.slice(6, 6 + A))
          })
      }
    },
    e.parseVoipMoonServerMessage = function (e, t) {
      var R = new Uint8Array(e);
      switch (parseInt("0x" + g(R.slice(0, 2)))) {
        case AG_VOIPMOONSERVER.Ft:
          t({
            type: "voipCallingAck",
            status: "success"
          });
          break;
        case AG_VOIPMOONSERVER.Wt:
          var a = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "voipCalling",
            status: "success",
            fingerprint: m(R.slice(4, 4 + a)),
            recSessionId: parseInt("0x" + g(R.slice(4 + a, 4 + a + 8)))
          });
          break;
        case AG_VOIPMOONSERVER.Bt:
          (O = {}).errId = parseInt("0x" + g(R.slice(2, 4))),
            O.errStrlen = parseInt("0x" + g(R.slice(4, 6))),
            O.errStr = m(R.slice(6, 6 + O.errStrlen)),
            t({
              type: "voipCalling",
              status: "failed",
              msg: O
            });
          break;
        case AG_VOIPMOONSERVER.Jt:
          a = parseInt("0x" + g(R.slice(2, 4)));
          t({
            type: "voipResponseing",
            status: "success",
            fingerprint: m(R.slice(4, 4 + a)),
            recSessionId: parseInt("0x" + g(R.slice(4 + a, 4 + a + 8)))
          });
          break;
        case AG_VOIPMOONSERVER.Qt:
          (O = {}).errId = parseInt("0x" + g(R.slice(2, 4))),
            O.errStrlen = parseInt("0x" + g(R.slice(4, 6))),
            O.errStr = m(R.slice(6, 6 + O.errStrlen)),
            t({
              type: "voipResponseing",
              status: "failed",
              msg: O
            });
          break;
        case AG_VOIPMOONSERVER.jt:
        case AG_VOIPMOONSERVER.Xt:
          break;
        case AG_VOIPMOONSERVER.zt:
          var O;
          (O = {}).errId = parseInt("0x" + g(R.slice(2, 4))),
            O.errStrlen = parseInt("0x" + g(R.slice(4, 6))),
            O.errStr = m(R.slice(6, 6 + O.errStrlen)),
            t({
              type: "serverErr",
              status: "failed",
              msg: O
            })
      }
    },
    e.constructHeartBeatMsg = function (e) {
      return new Uint8Array(J(W(e.toString(16))))
    }
},
StarRtc.StarConfig = function () {
    this.configModePulic = !1,
      this.configUseAEC = !1,
      this.msgServerUrl = "demo.starrtc.com",
      this.msgServerWebsocketPort = "19903",
      this.chatRoomServerUrl = "demo.starrtc.com",
      this.chatRoomServerWebsocketPort = "19906",
      this.srcServerUrl = "demo.starrtc.com",
      this.srcServerWebsocketPort = "19934",
      this.srcServerWebrtcPort = "19935",
      this.srcServerWebrtcIP = "demo.starrtc.com",
      this.vdnServerUrl = "demo.starrtc.com",
      this.vdnServerWebsocketPort = "19940",
      this.vdnServerWebrtcPort = "19941",
      this.vdnServerWebrtcIP = "demo.starrtc.com",
      this.voipServerUrl = "demo.starrtc.com",
      this.voipServerPort = "10086",
      this.voipServerWebsocketPort = "10087",
      this.voipServerWebrtcPort = "10088",
      this.voipServerWebrtcIP = "demo.starrtc.com"
  },
  StarRtc.StarUserInfo = function () {
    this.agentId = "APPID-FREE",
      this.userId = "",
      this.starUid = "",
      this.starToken = "free"
  },
  StarRtc.StarStaticInterface = new

function () {
  var S = this;
  S.reportRoom = function (e, t, R, a, O, E) {
      var _ = null,
        r = O.id.substring(16, 33);
      "" != r && null != r || (r = O.id);
      var n = {};
      n.id = O.id,
        n.creator = O.creator,
        n.name = O.name;
      var s = function (e, t) {
          switch (e.obj = S, t) {
            case "connect success":
              _.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Gt, {
                  roomId: r,
                  listType: a,
                  userDefineData: encodeURIComponent(JSON.stringify(n))
                },
                R)));
              break;
            case "connect failed":
              E && E("failed");
            case "connect closed":
              _ = null;
              break;
            case "onmessage":
              StarRtc.AUtils.parseProtocol(e,
                function (e) {
                  e.appid == APP_PRODUCT_ID.R && StarRtc.AUtils.parseChatMoonServerMessage(e.msgArr,
                    function (e) {
                      s(e, "onChatRoomMessage")
                    })
                });
              break;
            case "onChatRoomMessage":
              switch (e.type) {
                case "saveToChatroomList":
                  E && E(e.status),
                    _.close()
              }
          }
        },
        c = "wss://" + e + ":" + t;
      (_ = new StarRtc.WebrtcWebsocket(s, null)).connect(c)
    },
    S.queryRoom = function (e, t, O, E, _) {
      var r = null,
        n = function (e, t) {
          switch (e.obj = S, t) {
            case "connect success":
              r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.dt, {
                  listTypes: E.toString(),
                  userId: ""
                },
                O)));
              break;
            case "connect failed":
              _ && _("failed", []);
            case "connect closed":
              r = null;
              break;
            case "onmessage":
              StarRtc.AUtils.parseProtocol(e,
                function (e) {
                  e.appid == APP_PRODUCT_ID.R && StarRtc.AUtils.parseChatMoonServerMessage(e.msgArr,
                    function (e) {
                      n(e, "onChatRoomMessage")
                    })
                });
              break;
            case "onChatRoomMessage":
              switch (e.type) {
                case "queryAllChatroomList":
                  if ("" == e.listData) {
                    _ && _(e.status, []);
                    break
                  }
                  for (var R = JSON.parse(e.listData).userDefineDataList.split(","), a = 0; a < R.length; a++) R[a] = JSON.parse(decodeURIComponent(R[a]));
                  _ && _(e.status, R),
                    r.close()
              }
          }
        },
        R = "wss://" + e + ":" + t;
      (r = new StarRtc.WebrtcWebsocket(n, null)).connect(R)
    },
    S.delRoom = function (e, t, R, a, O, E) {
      var _ = null,
        r = O.id.substring(16, 33);
      "" != r && null != r || (r = O.id);
      var n = function (e, t) {
          switch (e.obj = S, t) {
            case "connect success":
              _.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Dt, {
                  roomId: r,
                  listType: a
                },
                R)));
              break;
            case "connect failed":
              E && E("failed");
            case "connect closed":
              _ = null;
              break;
            case "onmessage":
              StarRtc.AUtils.parseProtocol(e,
                function (e) {
                  e.appid == APP_PRODUCT_ID.R && StarRtc.AUtils.parseChatMoonServerMessage(e.msgArr,
                    function (e) {
                      n(e, "onChatRoomMessage")
                    })
                });
              break;
            case "onChatRoomMessage":
              switch (e.type) {
                case "delFromToChatroomList":
                  E && E(e.status),
                    _.close()
              }
          }
        },
        s = "wss://" + e + ":" + t;
      (_ = new StarRtc.WebrtcWebsocket(n, null)).connect(s)
    }
},
StarRtc.StarSDK = function () {
    var e = "starRTC v1.1.7",
      r = this,
      O = null,
      E = null,
      _ = 0;
    r.starConfig = new StarRtc.StarConfig,
      r.starUser = new StarRtc.StarUserInfo;
    var n = null;
    r.testSdk = function () {
      alert(1);
    };
    r.version = function () {
      return StarRtc.info(e),
        e
    };
    var s = function (e, t) {
      switch (t) {
        case "connect success":
          r.startAuth(),
            O(e, t);
          break;
        case "connect failed":
        case "connect closed":
          n = null,
            O(e, t);
          break;
        case "onmessage":
          StarRtc.AUtils.parseProtocol(e,
            function (e) {
              switch (e.appid) {
                case APP_PRODUCT_ID.t:
                  StarRtc.AUtils.parseMessage(e.msgArr, s)
              }
            });
          break;
        case "onSingleMessage":
          null != e.msgNode && (c(e, r.starUser), e.msgNode = void 0),
            e.msg = JSON.parse(e.msg);
          var R = t;
          if (0 == e.msg.type) switch (e.msg.code) {
            case AG_MSG_VOIP_CTRL.h:
              e.type = "voipCall",
                R = "onVoipMessage";
              break;
            case AG_MSG_VOIP_CTRL.Y:
              e.type = "voipAudioCall",
                R = "onVoipMessage";
              break;
            case AG_MSG_VOIP_CTRL.F:
              e.type = "voipRefuse",
                R = "onVoipMessage";
              break;
            case AG_MSG_VOIP_CTRL.K:
              e.type = "voipHangup",
                R = "onVoipMessage";
              break;
            case AG_MSG_VOIP_CTRL.W:
              e.type = "voipBusy",
                R = "onVoipMessage";
              break;
            case AG_MSG_VOIP_CTRL.B:
              e.type = "voipConnect",
                R = "onVoipMessage";
              break;
            default:
              e.type = "voipSingleMsg"
          } else e.type = "voipSingleMsg";
          (null != E ? E : O)(e, R);
          break;
        case "onLoginMessage":
          if ("success" == e.status) {
            e.msgMaxLen;
            var a = StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructHeartBeatMsg(AG_MSG.X));
            null != n && n.startHeartBeat(a, 15e3)
          }
          case "onGroupMessage":
          case "onGroupPrivateMessage":
          case "onGroupPushMessage":
          case "onSystemPushMessage":
            null != e.msgNode && (c(e, r.starUser), e.msgNode = void 0);
          case "onErrorMessage":
          case "onGetGroupList":
          case "onGetOnlineNumber":
          case "onGetGroupUserList":
          case "onGetAllUserList":
          case "onPushGroupSystemMsgFin":
          case "onPushSystemMsgFin":
          case "onUnsetGroupMsgIgnoreFin":
          case "onSetGroupMsgIgnoreFin":
          case "onRemoveGroupUserFin":
          case "onAddGroupUserFin":
          case "onDelGroupFin":
          case "onCreateGroupFin":
          case "onSendGroupMsgFin":
            null != E && E(e, t),
              O(e, t)
      }
    };

    function c(e, t) {
      StarRtc.debug(""),
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructReceivedMsg(e, t)))
    }
    return r.setMsgServerInfo = function (e, t) {
        r.starConfig.msgServerUrl = e,
          r.starConfig.msgServerWebsocketPort = t
      },
      r.setChatRoomServerInfo = function (e, t) {
        r.starConfig.chatRoomServerUrl = e,
          r.starConfig.chatRoomServerWebsocketPort = t
      },
      r.setSrcServerInfo = function (e, t, R, a) {
        r.starConfig.srcServerUrl = e,
          r.starConfig.srcServerWebsocketPort = t,
          r.starConfig.srcServerWebrtcPort = R,
          r.starConfig.srcServerWebrtcIP = a || e
      },
      r.setVdnServerInfo = function (e, t, R, a) {
        r.starConfig.vdnServerUrl = e,
          r.starConfig.vdnServerWebsocketPort = t,
          r.starConfig.vdnServerWebrtcPort = R,
          r.starConfig.vdnServerWebrtcIP = a || e
      },
      r.setVoipServerInfo = function (e, t, R, a, O) {
        r.starConfig.voipServerUrl = e,
          r.starConfig.voipServerPort = t,
          r.starConfig.voipServerWebsocketPort = R,
          r.starConfig.voipServerWebrtcPort = a,
          r.starConfig.voipServerWebrtcIP = O || e
      },
      r.setConfigUseAEC = function (e) {
        r.starConfig.configUseAEC = e
      },
      r.login = function (e, t, R) {
        r.starConfig.configModePulic || (e = "APPID-FREE"),
          r.starUser.agentId = e,
          r.starUser.userId = t,
          r.starUser.starUid = e + "_" + t,
          O = R,
          function (e) {
            if ("WebSocket" in window) {
              r.starUser.agentId,
                r.starUser.userId,
                r.starUser.starUid;
              r.starConfig.configModePulic || (r.starUser.starToken = "free", (n = new StarRtc.WebrtcWebsocket(e, null)).connect("wss://" + r.starConfig.msgServerUrl + ":" + r.starConfig.msgServerWebsocketPort))
            } else StarRtc.error(" Not support websocket"),
              e({
                  msg: " Not support websocket"
                },
                "connect failed")
          }(s)
      },
      window.onbeforeunload = function () {
        r.logout()
      },
      r.logout = function () {
        null != n && (n.close(), n = null)
      },
      r.send = function (e) {
        null != n && n.send(e)
      },
      r.startAuth = function () {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructAuthMsg(r.starUser)))
      },
      r.sendSingleMsg = function (e, t, R, a) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructSingleMsg(e, ++_, t, R, a, r.starUser)))
      },
      r.sendGroupMsg = function (e, t, R) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructGroupMsg(e, ++_, t, R, r.starUser)))
      },
      r.sendSingleCtrlMsg = function (e, t, R, a) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructSingleCtrlMsg(e, ++_, t, R, a, r.starUser)))
      },
      r.sendVoipCtrlMsg = function (e, t) {
        var R = "";
        t != AG_MSG_VOIP_CTRL.h && t != AG_MSG_VOIP_CTRL.Y || (R = JSON.stringify({
            VoIP_protocal_type: "TCP",
            VoIP_server_IP: r.starConfig.voipServerUrl,
            VoIP_server_Port: r.starConfig.voipServerPort
          })),
          r.sendSingleCtrlMsg(e, "", R, t)
      },
      r.sendVoipCallMsg = function (e, t, R) {
        var a;
        R = R || !1;
        var O = t || (new Date).getTime();
        a = JSON.stringify({
            VoIP_protocal_type: "TCP",
            VoIP_server_IP: r.starConfig.voipServerUrl,
            VoIP_server_Port: r.starConfig.voipServerPort,
            ts: O
          }),
          r.sendSingleCtrlMsg(e, "", a, R ? AG_MSG_VOIP_CTRL.Y : AG_MSG_VOIP_CTRL.h)
      },
      r.sendVoipRefuseMsg = function (e) {
        r.sendVoipCtrlMsg(e, AG_MSG_VOIP_CTRL.F)
      },
      r.sendVoipHungupMsg = function (e) {
        r.sendVoipCtrlMsg(e, AG_MSG_VOIP_CTRL.K),
          null != E && E({
              type: "voipCancle"
            },
            "onVoipMessage")
      },
      r.sendVoipBusyMsg = function (e) {
        r.sendVoipCtrlMsg(e, AG_MSG_VOIP_CTRL.W)
      },
      r.sendVoipConnectMsg = function (e) {
        r.sendVoipCtrlMsg(e, AG_MSG_VOIP_CTRL.B)
      },
      r.setIMExtraback = function (e) {
        E = e
      },
      r.getStarRoomSDK = function (e, t, R, a, O, E, _) {
        return new StarRtc.StarRoomSDK(e, t, R, a, O, E, _, r.starUser, r.starConfig)
      },
      r.getVideoMeetingRoomSDK = function (e, t, R) {
        return r.getStarRoomSDK("src", e, t, R, 3, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_MEETING)
      },
      r.getVideoLiveRoomSDK = function (e, t, R, a) {
        return r.getStarRoomSDK(e, t, R, a, 3, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_LIVE)
      },
      r.getVoipRoomSDK = function (e, t, R) {
        return r.getStarRoomSDK("voip", e, t, R, 2, 0, r)
      },
      r.getChatRoomSDK = function (e, t, R) {
        return new StarRtc.StarChatRoomSDK(e, t, R, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_CHATROOM, r.starUser, r.starConfig)
      },
      r.getVideoRoomSDK = function (e, t, R, a, O) {
        return new StarRtc.StarVideoRoomSDK(e, t, R, a, O, r.starUser, r.starConfig)
      },
      r.queryRoom = function (e, t) {
        r.starConfig.configUseAEC || StarRtc.StarStaticInterface.queryRoom(r.starConfig.chatRoomServerUrl, r.starConfig.chatRoomServerWebsocketPort, r.starUser, e.join(","), t)
      },
      r.setGroupMsgPush = function (e) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(e ? AG_MSG.Oe : AG_MSG.Ee, {
            reqIndex: 0
          },
          r.starUser)))
      },
      r.removeGroupUsers = function (e, t) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.ae, {
            reqIndex: 0,
            groupId: e,
            removeUsers: t.join(",")
          },
          r.starUser)))
      },
      r.addGroupUsers = function (e, t, R) {
        R = R || "",
          r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.Re, {
              reqIndex: 0,
              groupId: e,
              addUsers: t.join(","),
              userDefineData: R
            },
            r.starUser)))
      },
      r.delGroup = function (e) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.te, {
            reqIndex: 0,
            groupId: e
          },
          r.starUser)))
      },
      r.createGroup = function (e, t) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.ee, {
            reqIndex: 0,
            addUsers: e.join(","),
            userDefineData: t
          },
          r.starUser)))
      },
      r.getGroupList = function () {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.de, {
            reqIndex: 0
          },
          r.starUser)))
      },
      r.getGroupUserList = function (e) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.be, {
            reqIndex: 0,
            groupId: e
          },
          r.starUser)))
      },
      r.getOnlineNumber = function () {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.ke, {},
          r.starUser)))
      },
      r.getAllUserList = function (e) {
        r.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.t, ACTION_GROUP_ID.M, StarRtc.AUtils.constructMsgProtocol(AG_MSG.ge, {
            reqPageNum: e
          },
          r.starUser)))
      },
      r.getSuperRoomSDK = function (e, t, R) {
        return new StarRtc.StarSuperRoomSDK(e, t, R, r.starUser, r.starConfig)
      },
      r.reportRoom = function (e, t, R) {
        r.starConfig.configUseAEC || StarRtc.StarStaticInterface.reportRoom(r.starConfig.chatRoomServerUrl, r.starConfig.chatRoomServerWebsocketPort, r.starUser, e, t, R)
      },
      r.delRoom = function (e, t, R) {
        r.starConfig.configUseAEC || StarRtc.StarStaticInterface.reportRoom(r.starConfig.chatRoomServerUrl, r.starConfig.chatRoomServerWebsocketPort, r.starUser, e, t, R)
      },
      r
  },
  StarRtc.WebrtcWebsocket = function (e, t) {
    var a, R = this,
      O = e,
      E = null;
    return R.startHeartBeat = function (e, t) {
        var R = t || 5e3;
        null != E && 1 == E.readyState && E.send(e),
          a = setInterval(function () {
              null != E && 1 == E.readyState && E.send(e)
            },
            R)
      },
      R.stopHeartBeat = function () {
        clearInterval(a)
      },
      R.connect = function (t) {
        StarRtc.debug("WebSocket:" + t),
          (E = new WebSocket(t)).onerror = function (e) {
            StarRtc.warn("WebSocket:" + t),
              O({
                  msg: "WebSocket",
                  data: e.data
                },
                "connect failed")
          },
          E.onopen = function () {
            StarRtc.debug("WebSocket:" + t),
              O({
                  msg: "WebSocket"
                },
                "connect success")
          },
          E.onmessage = function (e) {
            StarRtc.debug("onmessage", e.data),
              O(e.data, "onmessage")
          },
          E.onclose = function (e) {
            StarRtc.debug("WebSocket:" + t),
              R.stopHeartBeat(),
              O({
                  msg: "WebSocket",
                  data: e.code
                },
                "connect closed"),
              E = null
          }
      },
      R.send = function (e) {
        E.send(e)
      },
      R.close = function () {
        null != E && E.close()
      },
      R.readyState = function () {
        return null != E ? E.readyState : -1
      },
      R
  },
  StarRtc.StarSuperRoomSDK = function (e, t, R, a, O) {
    var E = this,
      _ = e,
      r = R,
      n = t,
      s = null,
      c = null,
      S = null,
      i = null,
      I = null,
      o = null,
      A = !1,
      N = a || new StarRtc.StarUserInfo,
      M = O || new StarRtc.StarConfig;

    function V(e) {
      if (null != e) {
        var t = e.getState();
        0 <= t && t < 2 && e.sigDisconnect()
      }
    }

    function u() {
      return !(3 != I.getState() && -1 != I.getState() || 3 != S.getState() && -1 != S.getState() || null != s && (null == s || 3 != s.getState() && -1 != s.getState()))
    }

    function C(e, t, R) {
      switch (e.userData = r, e.obj = E, t) {
        case "connect success":
          switch (R) {
            case "open":
              s.createStream({
                video:
                  !1,
                audio: !0
              });
              break;
            case "new":
              s.createNewSuperRoom()
          }
          break;
        case "connect closed":
          break;
        case "connect failed":
          s = null;
          break;
        case "onmessage":
          break;
        case "onWebrtcMessage":
          switch (e.type) {
            case "srcApplyUpload":
              n(e, t, _);
              break;
            case "streamCreated":
              "success" == e.status ? s.joinRoom() : n(e, t, _);
              break;
            case "delChannel":
              "success" == e.status ? n(e, t, _) : alert("");
              break;
            case "createChannel":
              "success" == e.status && (r.roomInfo.creator = N.userId, r.roomInfo.id = e.channelId + r.roomInfo.id, i.roomInfo.id = e.channelId, i.roomInfo.creator = N.userId, c.roomInfo.id = e.channelId, c.roomInfo.creator = N.userId, s.sigDisconnect(), s = null),
                n(e, t, _)
          }
      }
    }
    return c = clone(r),
      i = clone(r),
      o = clone(r),
      r.roomInfo.id && (c.roomInfo.id = r.roomInfo.id.substring(0, 16), i.roomInfo.id = r.roomInfo.id.substring(0, 16), o.roomInfo.id = r.roomInfo.id.substring(16, 33)),
      S = new StarRtc.StarVideoSDK("vdn", "open",
        function (e, t) {
          switch (e.userData = r, e.obj = E, t) {
            case "connect success":
              n(e, t, _);
              break;
            case "connect closed":
            case "connect failed":
              V(I),
                V(s),
                u() && n(e, t, _);
              break;
            case "onmessage":
              break;
            case "onWebrtcMessage":
              e.type,
                n(e, t, _)
          }
        },
        i, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_SUPER_ROOM, N, M),
      I = new StarRtc.StarChatSDK(e,
        function (e, t) {
          switch (e.userData = r, e.obj = E, t) {
            case "connect success":
              S.sigConnect();
              break;
            case "connect failed":
            case "connect closed":
              V(S),
                u() && n(e, t, _);
              break;
            case "onmessage":
              break;
            case "onChatRoomMessage":
              switch (e.type) {
                case "createChatRoom":
                  "success" == e.status && (r.roomInfo.id = e.chatroomId, r.roomInfo.creator = N.userId, c.roomInfo.chatroomId = e.chatroomId, i.roomInfo.chatroomId = e.chatroomId, (s = new StarRtc.StarVideoSDK("src", "new", C, c, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_SUPER_ROOM, N, M)).sigConnect());
                  break;
                case "deleteChatRoom":
                  "success" == e.status && s.deleteCurrRoom();
                  break;
                case "joinChatRoom":
                  "success" == e.status && S.joinRoom()
              }
              n(e, t, _)
          }
        },
        o, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_SUPER_ROOM, N, M),
      E.sigConnect = function () {
        A = !1,
          I.sigConnect()
      },
      E.sigDisconnect = function (e) {
        null == e && (e = !0),
          A = e,
          E.endTalk(e),
          S.sigDisconnect(e)
      },
      E.createNew = function () {
        I.createNew()
      },
      E.deleteCurrRoom = function () {
        I.deleteCurrRoom()
      },
      E.createStream = function (e) {
        null == e ? e = {
            video: !1,
            audio: !0
          } : e.video = !1,
          S.createStream(e)
      },
      E.joinRoom = function () {
        "new" != _ ? I.joinRoom() : S.joinRoom()
      },
      E.leaveRoom = function (e) {
        E.endTalk(),
          S.leaveRoom(e)
      },
      E.sendChatMsg = function (e) {
        I.sendChatMsg(e)
      },
      E.sendChatPrivateMsg = function (e, t) {
        I.sendChatPrivateMsg(e, t)
      },
      E.kickOutUser = function (e) {
        I.kickOutUser(e)
      },
      E.banToSendMsg = function (e, t) {
        I.banToSendMsg(e, t)
      },
      E.getRoomOnlineNum = function () {
        I.getRoomOnlineNum()
      },
      E.activeDisconnect = function () {
        return A
      },
      E.startTalk = function () {
        E.endTalk(),
          null == s && (s = new StarRtc.StarVideoSDK("src", "open", C, c, CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_SUPER_ROOM, N, M)).sigConnect()
      },
      E.endTalk = function () {
        null != s && (s.sigDisconnect(), s = null)
      },
      E
  },
  StarRtc.StarRoomSDK = function (e, t, R, a, O, E, _, r, n) {
    var s = "",
      c = this,
      S = r || new StarRtc.StarUserInfo,
      i = n || new StarRtc.StarConfig,
      I = t,
      o = e,
      A = a,
      N = R,
      M = O || 3,
      V = 0 != (1 & M),
      u = 0 != (2 & M);
    "open" == t && 32 != A.roomInfo.id.length && (V = !1);
    var C = null,
      T = null,
      P = null,
      L = null,
      G = !1,
      l = null,
      f = _;

    function D() {
      null != l && (clearInterval(l), l = null)
    }

    function p(e) {
      if (null != e) {
        var t = e.getState();
        0 <= t && t < 2 && e.sigDisconnect()
      }
    }

    function U() {
      var e = !0;
      return V && (e = e && (3 == P.getState() || -1 == P.getState())),
        u && (e = e && (3 == C.getState() || -1 == C.getState())),
        e
    }
    null != f && "voip" == e && f.setIMExtraback(function (e, t) {
      d(e, "onVoipMessage")
    });
    var d = function (e, t) {
      switch (e.userData = A, e.obj = c, t) {
        case "connect success":
          u ? C.sigConnect() : N(e, t, I);
          break;
        case "connect failed":
        case "connect closed":
          u && p(C),
            U() && N(e, t, I);
          break;
        case "onmessage":
          break;
        case "onChatRoomMessage":
          switch (e.type) {
            case "createChatRoom":
              "success" == e.status && (A.roomInfo.id = e.chatroomId, A.roomInfo.creator = S.userId, u && (T.roomInfo.chatroomId = e.chatroomId, C.createNew()));
              break;
            case "deleteChatRoom":
              "success" == e.status && (u ? C.deleteCurrRoom() : N(e, t, I));
              break;
            case "joinChatRoom":
              "success" == e.status && u && C.joinRoom();
              break;
            case "recvChatPrivateMsg":
              if (0 == e.msg.type) switch (e.msg.code) {
                case 2e3:
                  e.msg.msgType = "apply";
                  break;
                case 2002:
                  e.msg.msgType = "applyAgree";
                  break;
                case 2004:
                  e.msg.msgType = "applyDisagree";
                  break;
                case 2200:
                  e.msg.msgType = "linkStop";
                  break;
                case 2100:
                  e.msg.msgType = "invite";
                  break;
                case 2102:
                  e.msg.msgType = "inviteAgree";
                  break;
                case 2106:
                  e.msg.msgType = "inviteDisagree";
                  break;
                case 2104:
                  e.msg.msgType = "inviteLinkStart";
                  break;
                default:
                  e.msg.msgType = "common"
              }
          }
          N(e, t, I);
          break;
        case "onVoipMessage":
          switch (e.type) {
            case "voipCall":
              e.fromId != A.roomInfo.targetId && f.sendVoipBusyMsg(e.fromId);
              break;
            case "voipHangup":
              e.fromId == A.roomInfo.targetId && (c.leaveRoom(!0), N(e, t, I));
              break;
            case "voipBusy":
              D(),
                c.leaveRoom(!0),
                N(e, t, I);
              break;
            case "voipConnect":
            case "voipRefuse":
              D(),
                N(e, t, I);
              break;
            case "voipCancle":
              D();
              break;
            default:
              N(e, t, I)
          }
      }
    };
    return T = clone(A),
      L = clone(A),
      u && V && A.roomInfo.id && (T.roomInfo.id = A.roomInfo.id.substring(0, 16), L.roomInfo.id = A.roomInfo.id.substring(16, 33)),
      u && (C = new StarRtc.StarVideoSDK(e, t,
        function (e, t) {
          switch (e.userData = A, e.obj = c, t) {
            case "connect success":
              N(e, t, I);
              break;
            case "connect closed":
            case "connect failed":
              D(),
                V && p(P),
                U() && N(e, t, I);
              break;
            case "onmessage":
              break;
            case "onWebrtcMessage":
              switch (e.type) {
                case "delChannel":
                  "success" == e.status ? N(e, t, I) : alert("");
                  break;
                case "createChannel":
                  "success" == e.status && (A.roomInfo.creator = S.userId, A.roomInfo.id = V ? e.channelId + A.roomInfo.id : e.channelId),
                    N(e, t, I);
                  break;
                case "voipCallingAck":
                  if (null != f) {
                    D();
                    var R = (new Date).getTime();
                    f.sendVoipCallMsg(A.roomInfo.targetId, R, A.roomInfo.audioOnly),
                      function (e, t) {
                        null != l && D(),
                          l = setInterval(e, t)
                      }((a = A.roomInfo.targetId,
                        function () {
                          f.sendVoipCallMsg(a, R, A.roomInfo.audioOnly)
                        }), 3e3)
                  }
                  break;
                case "voipResponseing":
                  "success" == e.status && null != f && f.sendVoipConnectMsg(A.roomInfo.targetId),
                    N(e, t, I);
                  break;
                default:
                  N(e, t, I)
              }
          }
          var a
        }, T, E, S, i)), V && (P = new StarRtc.StarChatSDK(t, d, L, E, S, i)),
      c.sigConnect = function () {
        G = !1,
          V ? P.sigConnect() : u && C.sigConnect()
      },
      c.sigDisconnect = function (e) {
        null == e && (e = !0),
          G = e,
          u ? C.sigDisconnect(e) : V && P.sigDisconnect(e)
      },
      c.createNew = function () {
        "voip" != o && (V ? P.createNew() : u && C.createNew())
      },
      c.deleteCurrRoom = function () {
        "voip" != o && (V ? P.deleteCurrRoom() : u && C.deleteCurrRoom())
      },
      c.createStream = function (e) {
        u && C.createStream(e)
      },
      c.publishStream = function (e) {
        u && C.publishStream(e)
      },
      c.createScreenCaptureStream = function (e) {
        u && C.createScreenCaptureStream(e)
      },
      c.joinRoom = function () {
        V && "new" != I ? P.joinRoom() : u && C.joinRoom()
      },
      c.leaveRoom = function (e) {
        if (u) {
          switch (o) {
            case "voip":
              var t = e || !1;
              null == f || t || f.sendVoipHungupMsg(A.roomInfo.targetId),
                f.setIMExtraback(null)
          }
          C.leaveRoom(t)
        } else V && P.leaveRoom()
      },
      c.streamConfigChange = function (e) {
        u && C.streamConfigChange(e)
      },
      c.streamConfigApply = function (e) {
        u && C.streamConfigApply(e)
      },
      c.sendChatMsg = function (e) {
        V && P.sendChatMsg(e)
      },
      c.sendVoipMsg = function (e) {
        "voip" == o && null != f && f.sendSingleMsg(A.roomInfo.targetId, "", e)
      },
      c.sendChatPrivateMsg = function (e, t) {
        V && P.sendChatPrivateMsg(e, t)
      },
      c.sendApplyMsg = function () {
        V && u && "vdn" == o && P.sendChatCtrlPrivateMsg(A.roomInfo.creator, s, 2e3)
      },
      c.sendApplyAgreeMsg = function (e) {
        V && u && "src" == o && P.sendChatCtrlPrivateMsg(e, s, 2002)
      },
      c.sendApplyDisagreeMsg = function (e) {
        V && u && "src" == o && P.sendChatCtrlPrivateMsg(e, s, 2004)
      },
      c.sendInviteLinkMsg = function (e) {
        V && u && "src" == o && P.sendChatCtrlPrivateMsg(e, s, 2100)
      },
      c.sendInviteLinkAgreeMsg = function () {
        V && u && "vdn" == o && P.sendChatCtrlPrivateMsg(A.roomInfo.creator, s, 2102)
      },
      c.sendInviteLinkDisagreeMsg = function () {
        V && u && "vdn" == o && P.sendChatCtrlPrivateMsg(A.roomInfo.creator, s, 2106)
      },
      c.sendInviteLinkStartMsg = function () {
        V && u && "vdn" == o && P.sendChatCtrlPrivateMsg(A.roomInfo.creator, s, 2104)
      },
      c.sendLinkStopMsg = function (e) {
        V && u && "src" == o && P.sendChatCtrlPrivateMsg(e, s, 2200)
      },
      c.kickOutUser = function (e) {
        V && P.kickOutUser(e)
      },
      c.banToSendMsg = function (e, t) {
        V && P.banToSendMsg(e, t)
      },
      c.getRoomOnlineNum = function () {
        V && P.getRoomOnlineNum()
      },
      c.sendStreamData = function (e) {
        u && "src" == o && C.sendStreamData(e)
      },
      c.activeDisconnect = function () {
        return G
      },
      c
  },
  StarRtc.StarVideoRoomSDK = function (e, t, R, a, O, E, _) {
    var r = this,
      n = a,
      s = R,
      c = t,
      S = e,
      i = O || CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_MEETING,
      I = E || new StarRtc.StarUserInfo,
      o = _ || new StarRtc.StarConfig,
      A = new StarRtc.StarVideoSDK(S, c,
        function (e, t) {
          e.userData = n,
            e.obj = r,
            s(e, t, c)
        },
        n, i, I, o);
    return r.sigConnect = function () {
        A.sigConnect()
      },
      r.sigDisconnect = function (e) {
        A.sigDisconnect(e)
      },
      r.createNew = function () {
        A.createNew()
      },
      r.createNewSuperRoom = function () {
        A.createNewSuperRoom()
      },
      r.deleteCurrRoom = function () {
        A.deleteCurrRoom()
      },
      r.createStream = function (e) {
        A.createStream(e)
      },
      r.publishStream = function (e) {
        A.publishStream(e)
      },
      r.createScreenCaptureStream = function (e) {
        A.createScreenCaptureStream(e)
      },
      r.joinRoom = function () {
        A.joinRoom()
      },
      r.leaveRoom = function (e) {
        A.leaveRoom(e)
      },
      r.streamConfigChange = function (e) {
        A.streamConfigChange(e)
      },
      r.streamConfigApply = function (e) {
        A.streamConfigApply(e)
      },
      r.getState = function () {
        return A.getState()
      },
      r.getType = function () {
        return A.getType()
      },
      r.sendStreamData = function (e) {
        A.sendStreamData(e)
      },
      r.activeDisconnect = function () {
        return A.activeDisconnect()
      },
      r
  },
  StarRtc.StarVideoSDK = function (e, t, R, a, O, E, _) {
    var n = this,
      s = a,
      c = e,
      S = R,
      i = t,
      I = null,
      o = "",
      A = {},
      N = {},
      M = E || new StarRtc.StarUserInfo,
      r = _ || new StarRtc.StarConfig,
      V = O || CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_MEETING,
      u = {
        siv: 0,
        uperInfos: {}
      },
      C = StarWebRTC();
    C.init();

    function T(e) {
      switch (e.type) {
        case "createOffer":
          if ("success" == e.status) {
            switch (null != e.audioCodec && "0" != e.audioCodec || (e.audioCodec = 111), null != e.videoCodec && "0" != e.videoCodec || (e.videoCodec = 102), c) {
              case "src":
                e.channelId = s.roomInfo.id;
                break;
              case "vdn":
                e.ssrc = e.bigVideoSSRC;
                break;
              case "voip":
                e.targetId = s.roomInfo.targetId,
                  e.videoSSRC = e.bigVideoSSRC
            }!
            function (e) {
              switch (N = e, c) {
                case "src":
                  I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.ha, e, M)));
                  break;
                case "vdn":
                  I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.I, ACTION_GROUP_ID.C, StarRtc.AUtils.constructVdnProtocol(AG_LIVEVDNMOONSERVER.Ba, e, M)));
                  break;
                case "voip":
                  "call" == i ? I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.o, ACTION_GROUP_ID.T, StarRtc.AUtils.constructVOIPProtocol(AG_VOIPMOONSERVER.gt, e, M))) : "response" == i && I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.o, ACTION_GROUP_ID.T, StarRtc.AUtils.constructVOIPProtocol(AG_VOIPMOONSERVER.yt, e, M)))
              }
            }(e)
          }
          break;
        case "applyAnswer":
          e.status
      }
    }

    function P(e, t) {
      var R = {
        type: "streamCreated",
        streamObj: t
      };
      R.userData = s,
        R.obj = n,
        "success" == e ? R.status = "success" : (R.status = "failed", R.error = t),
        S(R, "onWebrtcMessage", i)
    }
    var L = !1,
      G = !1,
      l = !1;

    function f() {
      G && L &&
        function () {
          switch (c) {
            case "vdn":
              I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.I, ACTION_GROUP_ID.C, StarRtc.AUtils.constructVdnProtocol(AG_LIVEVDNMOONSERVER.qa, {
                  channelId: s.roomInfo.id
                },
                M)));
              break;
            case "src":
              I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.YR, N, M)))
          }
        }()
    }
    var D = function (e, t) {
      switch (e.userData = s, e.obj = n, t) {
        case "connect success":
          var R = null;
          switch (c) {
            case "src":
              R = StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructHeartBeatMsg(AG_LIVESRCMOONSERVER.zR));
              break;
            case "vdn":
              R = StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.I, ACTION_GROUP_ID.C, StarRtc.AUtils.constructHeartBeatMsg(AG_LIVEVDNMOONSERVER.Qa))
          }
          I.startHeartBeat(R),
            C.setServerInfo({
              serverIp: A.webrtcIP,
              serverPort: A.webrtcPort
            }),
            S(e, t, i);
          break;
        case "connect failed":
        case "connect closed":
          C.destroy(),
            I = null,
            S(e, t, i);
          break;
        case "onmessage":
          StarRtc.AUtils.parseProtocol(e,
            function (e) {
              e.appid == APP_PRODUCT_ID.i ? StarRtc.AUtils.parseSrcMoonServerMessage(e.msgArr,
                function (e) {
                  D(e, "onWebrtcMessage")
                }) : e.appid == APP_PRODUCT_ID.I ? StarRtc.AUtils.parseVdnMoonServerMessage(e.msgArr,
                function (e) {
                  D(e, "onWebrtcMessage")
                }) : e.appid == APP_PRODUCT_ID.o && StarRtc.AUtils.parseVoipMoonServerMessage(e.msgArr,
                function (e) {
                  D(e, "onWebrtcMessage")
                })
            });
          break;
        case "onWebrtcMessage":
          switch (e.type) {
            case "uperStreamInfoUpdate":
              if ("success" == e.status) {
                if (L)
                  for (var a = 0; a < 7; ++a) {
                    var O = C.getStreamByIndex(a),
                      E = void 0;
                    0 != Object.keys(u.uperInfos).length && (E = u.uperInfos[a]);
                    var _ = e.msg.uperInfos[a];
                    null == E && null != _ ? "vdn" != c && _.userId == M.starUid || S({
                        type: "addUploader",
                        upId: _.upId,
                        upUserId: _.userId,
                        streamInfo: O,
                        room: n
                      },
                      t, i) : null != E && null == _ ? S({
                        type: "removeUploader",
                        upId: E.upId,
                        upUserId: E.userId,
                        streamInfo: O,
                        room: n
                      },
                      t, i) : null != E && null != _ && E.userId != _.userId && S({
                        type: "changeUploader",
                        upId: _.upId,
                        oldUpUserId: E.userId,
                        newUpUserId: _.userId,
                        streamInfo: O,
                        room: n
                      },
                      t, i)
                  }
                u = e.msg
              }
              break;
            case "webrtcConnect":
              StarRtc.debug("webrtcConnect:" + e.status),
                "success" == e.status && (G = !0, f());
              break;
            case "webrtcReg":
              if (StarRtc.debug("webrtcReg:" + e.status), "success" == e.status) switch (G = L = !1, c) {
                case "vdn":
                case "src":
                  o = e.fingerprint,
                    C.emit("_webrtc_apply_ok", o,
                      function () {
                        L = !0,
                          f()
                      },
                      102, 111)
              } else StarRtc.error("webrtcReg failed");
              break;
            case "vdnApplyDownload":
              "success" == e.status ? D({
                    type: "uperStreamInfoUpdate",
                    status: "success",
                    msg: e.uperInfos
                  },
                  "onWebrtcMessage") : StarRtc.warn("vdnApplyDownload failed"),
                S(e, t, i);
              break;
            case "srcApplyUpload":
              if ("success" == e.status) {
                e.tmpData = N,
                  StarRtc.info("_webrtc_apply_ok");
                var r = clone(u);
                u.uperInfos = {},
                  D({
                      type: "uperStreamInfoUpdate",
                      status: "success",
                      msg: r
                    },
                    "onWebrtcMessage")
              } else StarRtc.warn("srcApplyUpload failed");
              S(e, t, i);
              break;
            case "streamConfig":
              e.status,
                S(e, t, i);
              break;
            case "createChannel":
              "success" == e.status && (s.roomInfo.id = e.channelId, s.roomInfo.creator = M.userId),
                S(e, t, i);
              break;
            case "delChannel":
              "success" == e.status && (s.roomInfo.id = ""),
                S(e, t, i);
              break;
            case "serverErr":
              break;
            case "voipResponseing":
            case "voipCalling":
              "success" == e.status && (StarRtc.info("_webrtc_apply_ok"), C.emit("_webrtc_apply_ok", e.fingerprint,
                  function () {
                    D({
                        type: "voipStreamReady",
                        status: "success"
                      },
                      "onWebrtcMessage")
                  },
                  102, 111)),
                S(e, t, i);
              break;
            case "voipStreamReady":
              O = C.getStreamByIndex(0);
              C.switchStreamInfo(O),
                S({
                    type: "voipStreamReady",
                    streamObj: O.streamObj,
                    room: n
                  },
                  t, i);
              break;
            case "streamInactive":
              n.leaveRoom(),
                n.sigDisconnect();
              break;
            default:
              S(e, t, i)
          }
      }
    };
    return n.sigConnect = function () {
        switch (l = !1, I = null, c) {
          case "src":
            if (r.configModePulic) break;
            I = new StarRtc.WebrtcWebsocket(D, null),
              (t = {}).ip = r.srcServerUrl,
              A.ip = t.ip,
              A.websocketPort = r.srcServerWebsocketPort,
              A.webrtcPort = r.srcServerWebrtcPort,
              A.webrtcIP = r.srcServerWebrtcIP,
              t.websocketPort = A.websocketPort;
            var e = "wss://" + t.ip + ":" + t.websocketPort;
            return void I.connect(e);
          case "vdn":
            if (r.configModePulic) break;
            I = new StarRtc.WebrtcWebsocket(D, null),
              (t = {}).ip = r.vdnServerUrl,
              A.ip = t.ip,
              A.websocketPort = r.vdnServerWebsocketPort,
              A.webrtcPort = r.vdnServerWebrtcPort,
              A.webrtcIP = r.vdnServerWebrtcIP,
              t.websocketPort = A.websocketPort;
            e = "wss://" + t.ip + ":" + t.websocketPort;
            return void I.connect(e);
          case "voip":
            var t;
            I = new StarRtc.WebrtcWebsocket(D, null),
              (t = {}).ip = r.voipServerUrl,
              A.ip = t.ip,
              A.websocketPort = r.voipServerWebsocketPort,
              A.webrtcPort = r.voipServerWebrtcPort,
              A.webrtcIP = r.voipServerWebrtcIP,
              t.websocketPort = A.websocketPort;
            e = "wss://" + t.ip + ":" + t.websocketPort;
            return void I.connect(e);
          default:
            return
        }
      },
      n.sigDisconnect = function (e) {
        null == e && (e = !0),
          l = e,
          null != I && (I.close(), I = null)
      },
      n.createNew = function () {
        if (null != I) switch (c) {
          case "src":
            var e = AG_LIVESRCMOONSERVER.mR;
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(e, {
                conCurrentNum: 7,
                roomId: s.roomInfo.chatroomId || "",
                extra: s.roomInfo.name,
                liveType: V
              },
              M)))
        }
      },
      n.createNewSuperRoom = function () {
        if (null != I) switch (c) {
          case "src":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.Fa, {
                conCurrentNum: 7,
                roomId: s.roomInfo.chatroomId || "",
                extra: s.roomInfo.name,
                liveType: V
              },
              M)))
        }
      },
      n.deleteCurrRoom = function () {
        if (null != I) switch (c) {
          case "src":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.JR, {
                channelId: s.roomInfo.id
              },
              M)))
        }
      },
      n.createStream = function (e) {
        null == e && (e = {
            video: {
              width: {
                ideal: 640
              },
              height: {
                ideal: 480
              },
              frameRate: {
                ideal: 25
              },
              facingMode: {
                ideal: ["user"]
              }
            },
            audio: !0
          }),
          "vdn" == c && (e = {
            video: !1,
            audio: !1
          }),
          "voip" == c && s.roomInfo.audioOnly && (e.video = !1),
          C.createStream(e, P,
            function () {
              D({
                  type: "streamInactive"
                },
                "onWebrtcMessage")
            })
      },
      n.publishStream = function (e) {
        e = e || {
            video: !0,
            audio: !0
          },
          C.publishStream(e)
      },
      n.createScreenCaptureStream = function (e) {
        null == e && (e = {
            audio: !0
          }),
          C.createScreenCaptureStream(e, P,
            function () {
              D({
                  type: "streamInactive"
                },
                "onWebrtcMessage")
            })
      },
      n.joinRoom = function () {
        C.emit("ready", T, "voip" == c)
      },
      n.leaveRoom = function (e) {
        if (null != I && 1 == I.readyState()) switch (c) {
          case "src":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.qR, {
                channelId: s.roomInfo.id
              },
              M)));
            break;
          case "vdn":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.I, ACTION_GROUP_ID.C, StarRtc.AUtils.constructVdnProtocol(AG_LIVEVDNMOONSERVER.Ja, {},
              M)));
          case "voip":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.o, ACTION_GROUP_ID.T, StarRtc.AUtils.constructVOIPProtocol(AG_VOIPMOONSERVER.Yt, {
                isActive: e ? 0 : 1
              },
              M)))
        }
      },
      n.streamConfigChange = function (e) {},
      n.streamConfigApply = function (e) {
        switch (c) {
          case "src":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.QR, {
                streamConfig: e
              },
              M)));
            break;
          case "vdn":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.I, ACTION_GROUP_ID.C, StarRtc.AUtils.constructVdnProtocol(AG_LIVEVDNMOONSERVER.Xa, {
                streamConfig: e
              },
              M)))
        }
      },
      n.getState = function () {
        return null != I ? I.readyState() : -1
      },
      n.getType = function () {
        return c
      },
      n.sendStreamData = function (e) {
        switch (c) {
          case "src":
            I.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.i, ACTION_GROUP_ID.C, StarRtc.AUtils.constructSrcProtocol(AG_LIVESRCMOONSERVER.XR, {
                streamData: e,
                streamDataType: 8
              },
              M)))
        }
      },
      n.activeDisconnect = function () {
        return l
      },
      n
  },
  StarRtc.StarChatRoomSDK = function (e, t, R, a, O, E) {
    var _ = this,
      r = R,
      n = t,
      s = e,
      c = (a || CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_CHATROOM, O || new StarRtc.StarUserInfo),
      S = E || new StarRtc.StarConfig,
      i = new StarRtc.StarChatSDK(e,
        function (e, t) {
          switch (e.userData = r, e.obj = _, t) {
            case "onChatRoomMessage":
              e.type,
                n(e, t, s);
              break;
            default:
              n(e, t, s)
          }
        },
        r, a, c, S);
    return _.sigConnect = function () {
        i.sigConnect()
      },
      _.sigDisconnect = function (e) {
        i.sigDisconnect(e)
      },
      _.createNew = function () {
        i.createNew()
      },
      _.sendChatMsg = function (e) {
        i.sendChatMsg(e)
      },
      _.sendChatPrivateMsg = function (e, t) {
        i.sendChatPrivateMsg(e, t)
      },
      _.sendChatCtrlPrivateMsg = function (e, t, R) {
        i.sendChatCtrlPrivateMsg(e, t, R)
      },
      _.kickOutUser = function (e) {
        i.kickOutUser(e)
      },
      _.banToSendMsg = function (e, t) {
        i.banToSendMsg(e, t)
      },
      _.getRoomOnlineNum = function () {
        i.getRoomOnlineNum()
      },
      _.deleteCurrRoom = function () {
        i.deleteCurrRoom()
      },
      _.joinRoom = function () {
        i.joinRoom()
      },
      _.leaveRoom = function () {
        i.leaveRoom()
      },
      _.getState = function () {
        return i.getState()
      },
      _.activeDisconnect = function () {
        return i.activeDisconnect()
      },
      _
  },
  StarRtc.StarChatSDK = function (e, t, R, a, O, E) {
    var _ = this,
      r = {},
      n = R,
      s = t,
      c = e,
      S = null,
      i = 0,
      I = a || CHATROOM_LIST_TYPE.CHATROOM_LIST_TYPE_CHATROOM,
      o = O || new StarRtc.StarUserInfo,
      A = E || new StarRtc.StarConfig,
      N = !1,
      M = function (e, t) {
        switch (e.userData = n, e.obj = _, t) {
          case "connect success":
            var R;
            R = StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructHeartBeatMsg(AG_CHATROOMMOONSERVER.Be)),
              S.startHeartBeat(R),
              s(e, t, c);
            break;
          case "connect failed":
          case "connect closed":
            S = null,
              s(e, t, c);
            break;
          case "onmessage":
            StarRtc.AUtils.parseProtocol(e,
              function (e) {
                e.appid == APP_PRODUCT_ID.R && StarRtc.AUtils.parseChatMoonServerMessage(e.msgArr,
                  function (e) {
                    M(e, "onChatRoomMessage")
                  })
              });
            break;
          case "onChatRoomMessage":
            switch (e.type) {
              case "createChatRoom":
                "success" == e.status && (n.roomInfo.id = e.chatroomId, n.roomInfo.creator = o.userId);
                break;
              case "deleteChatRoom":
              case "joinChatRoom":
                e.status;
                break;
              case "recvChatPrivateMsg":
              case "recvChatMsg":
                if ("" == e.fromUserId || "" == e.msg) return;
                if (e.msg = JSON.parse(e.msg), e.msg.fromId == o.userId) return
            }
            s(e, t, c)
        }
      };
    return _.sigConnect = function () {
        if (N = !1, A.configModePulic);
        else {
          S = new StarRtc.WebrtcWebsocket(M, null),
            r.ip = A.chatRoomServerUrl,
            r.port = A.chatRoomServerWebsocketPort;
          var e = "wss://" + r.ip + ":" + r.port;
          S.connect(e)
        }
      },
      _.sigDisconnect = function (e) {
        null == e && (e = !0),
          N = e,
          null != S && (S.close(), S = null)
      },
      _.createNew = function () {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Ye, {
            roomType: 0 == n.roomInfo.Type ? 1 : 2,
            conCurrentNum: 100,
            userDefineData: n.roomInfo.name,
            liveType: I
          },
          o)))
      },
      _.sendChatMsg = function (e) {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.je, {
            roomId: n.roomInfo.id,
            digest: "",
            msgIndex: ++i,
            msg: e
          },
          o)))
      },
      _.sendChatPrivateMsg = function (e, t) {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Xe, {
            toUserId: e,
            roomId: n.roomInfo.id,
            digest: "",
            msgIndex: ++i,
            msg: t,
            type: "1",
            code: "0"
          },
          o)))
      },
      _.sendChatCtrlPrivateMsg = function (e, t, R) {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Xe, {
            toUserId: e,
            roomId: n.roomInfo.id,
            digest: "",
            msgIndex: ++i,
            msg: t,
            type: "0",
            code: R
          },
          o)))
      },
      _.kickOutUser = function (e) {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.We, {
            kickOutUserId: e
          },
          o)))
      },
      _.banToSendMsg = function (e, t) {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Ke, {
            banUserId: e,
            banTime: t
          },
          o)))
      },
      _.getRoomOnlineNum = function () {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.ze, {
            roomId: n.roomInfo.id
          },
          o)))
      },
      _.deleteCurrRoom = function () {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Fe, {},
          o)))
      },
      _.joinRoom = function () {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.qe, {
            roomId: n.roomInfo.id
          },
          o)))
      },
      _.leaveRoom = function () {
        S.send(StarRtc.AUtils.packageProtocol(APP_PRODUCT_ID.R, ACTION_GROUP_ID.V, StarRtc.AUtils.constructChatProtocol(AG_CHATROOMMOONSERVER.Qe, {},
          o)))
      },
      _.getState = function () {
        return null != S ? S.readyState() : -1
      },
      _.activeDisconnect = function () {
        return N
      },
      _
  };

export default StarRtc
